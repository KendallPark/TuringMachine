{"version":3,"sources":["webpack:///TMViz.bundle.js","webpack:///webpack/bootstrap cdd1786ab9de02b253e8","webpack:///external \"_\"","webpack:///external \"d3\"","webpack:///./src/util.js","webpack:///external \"lodash\"","webpack:///./src/TMViz.js","webpack:///./src/TuringMachine.js","webpack:///./src/watch.js","webpack:///./src/state-diagram/StateViz.css","webpack:///./src/tape/tape.css","webpack:///./src/state-diagram/StateGraph.js","webpack:///./src/state-diagram/StateViz.js","webpack:///./src/tape/Tape.js","webpack:///./src/tape/TapeViz.js"],"names":["TMViz","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","Object","prototype","hasOwnProperty","shift","0","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","1","appendChild","m","c","_","2","d3","3","nonNull","value","Error","String","coalesce","a","b","applyMaybe","f","x","getFirst","xs","val","toDocFragment","array","result","createDocumentFragment","forEach","bind","isBrowserIEorEdge","Boolean","documentMode","StyleMedia","6","lodash","10","animatedTransition","graph","animationCallback","state","symbol","tuple","getInstructionAndEdge","edge","instruction","pulseEdge","edgepath","select","domNode","classed","transition","style","duration","each","this","addTape","div","spec","TapeViz","append","attr","blank","input","split","posTable","animateAndContinue","self","edgeAnimation","isRunning","stepInterval","step","StateGraph","table","stateviz","StateViz","getVertexMap","getEdges","positionTable","machine","TuringMachine","startState","startIndex","watchInit","prop","oldstate","newstate","getVertex","isHalted","defineProperty","configurable","get","set","__parentDiv","__spec","reset","tape","remove","11","startPosition","headRight","move","direction","MoveHead","right","neutral","left","headLeft","TypeError","toString","instruct","nextInstruction","console","log","read","write","defineProperties","enumerable","freeze","MoveTape","16","watch","thisArg","handler","desc","getOwnPropertyDescriptor","writable","accessors","newval","19","20","48","deriveGraph","mapValues","transitions","label","allEdges","vertex","edgeTo","target","cache","tap","source","labels","stateTransitions","symbolKey","symbols","reduce","acc","labelFor","normalize","edges","defaults","action","rightSide","visibleSpace","map","join","derived","__graph","__edges","49","addV","array1","array2","negateV","subtractV","multiplyV","scalar","normSqV","sq","add","y","normV","Math","sqrt","unitV","n","angleV","atan2","vectorFromLengthAngle","angle","cos","sin","EdgeCounter","key","index","edgePathFor","nodeRadius","shape","d","loopEndOffset","loopArc","EdgeShape","loop","PI","x1","y1","arc","p1","p2","offset","radius","sep","straight","rectCenter","svgrect","width","height","identity","noop","limitRange","min","max","container","nodes","linkArray","dragstart","fixed","svg","dragend","releasenode","force","resume","w","h","linkDistance","colors","scale","category10","appendSVGTo","viewBox","version",":xmlns",":xmlns:xlink","nodeArray","Array","values","__stateMap","layout","links","size","charge","theta","gravity","start","drag","on","edgeCounter","edgeselection","selectAll","data","enter","edgegroups","labelAbove","labelBelow","edgeD","edgeIndex","group","class","byTarget","pieces","edgeLabels","keys","text","shapeForEdge","getPath","refreshLabels","getBBox","isFlipped","shouldFlip","edgepaths","nodeSelection","nodecircles","nodelabels","svgdefs","refX","lastIndexOf","orient","markerWidth","markerHeight","svgCSS","styleSheet","cssText","textContent","cx","cy","every","stop","setPositionTable","stateMap","node","position","assign","numEdgesFromTo","hwRatio","padding-bottom","top","getPositionTable","pick","50","toUnicodeVariant","str","variant","flags","offsets","bi","bc","g","bg","s","bs","is","bis","o","u","variantOffsets","monospace","bold","italic","bold italic","bold script","gothic","gothic bold","doublestruck","sans","bold sans","italic sans","bold italic sans","parenthesis","circled","fullwidth","special"," ","-","C","H","I","R","Z","4","5","7","8","9","fromCharCode","chars","numbers","getType","variantt","getFlag","flag","flagz","indexOf","underline","strike","k","charAt","fromCodePoint","Tape","before","after","slice","reverse","last","pop","isEmpty","readOffset","readRange","end","range","51","initTapeCells","selection","datum","cellWidth","cellHeight","positionCells","repositionWrapper","wrapper","lookaround","moveHead","exit","wOffset","cOffset","create","constructor","childNodes","insert"],"mappings":"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","file":"TMViz.bundle.js","sourcesContent":["var TMViz =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp_name_\"];\n/******/ \twindow[\"webpackJsonp_name_\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"1\":\"main\"}[chunkId]||chunkId) + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/build/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(10);\n\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\n\tmodule.exports = _;\n\n/***/ }),\n\n/***/ 2:\n/***/ (function(module, exports) {\n\n\tmodule.exports = d3;\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t// misc. utilities\n\t\n\t//////////////////////////////////\n\t// Utilities for null/undefined //\n\t//////////////////////////////////\n\t\n\t// Assert non-null.\n\t// Return the value if it is not null or undefined; otherwise, throw an error.\n\tfunction nonNull(value) {\n\t  if (value == null) {\n\t    throw new Error('expected a non-null defined value, but got: ' + String(value));\n\t  }\n\t  return value;\n\t}\n\t\n\t// Null coalescing: iff the first argument is null or undefined, return the second.\n\tfunction coalesce(a, b) {\n\t  return (a != null) ? a : b;\n\t}\n\t\n\t// Apply a function to a value if non-null, otherwise return the value.\n\t// (Monadic bind for maybe (option) type.)\n\t// ((a -> b), ?a) -> ?b\n\tfunction applyMaybe(f, x) {\n\t  return (x != null) ? f(x) : x;\n\t}\n\t\n\t// Returns the first function result that is not null or undefined.\n\t// Otherwise, returns undefined.\n\t// ((a -> ?b), [a]) -> ?b\n\tfunction getFirst(f, xs) {\n\t  for (var i = 0; i < xs.length; ++i) {\n\t    var val = f(xs[i]);\n\t    if (val != null) {\n\t      return val;\n\t    }\n\t  }\n\t}\n\t\n\t/////////\n\t// DOM //\n\t/////////\n\t\n\t/* global document */\n\t\n\t/**\n\t * Concat an array of DOM Nodes into a DocumentFragment.\n\t * @param  {[Node]} array\n\t * @return {DocumentFragment}\n\t */\n\tfunction toDocFragment(array) {\n\t  var result = document.createDocumentFragment();\n\t  array.forEach(result.appendChild.bind(result));\n\t  return result;\n\t}\n\t\n\t///////////////////////\n\t// IE/Edge detection //\n\t///////////////////////\n\t\n\t// http://stackoverflow.com/a/9851769\n\tvar isBrowserIEorEdge = /*@cc_on!@*/false\n\t  || Boolean(document.documentMode) || Boolean(window.StyleMedia); // eslint-disable-line\n\t\n\t\n\texports.nonNull = nonNull;\n\texports.coalesce = coalesce;\n\texports.applyMaybe = applyMaybe;\n\texports.getFirst = getFirst;\n\t\n\texports.toDocFragment = toDocFragment;\n\t\n\texports.isBrowserIEorEdge = isBrowserIEorEdge;\n\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports) {\n\n\tmodule.exports = lodash;\n\n/***/ }),\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Turing machine visualization component.\n\t *\n\t * • Adds running and reset on top of the base Turing machine.\n\t * • Displays an animated state diagram and tape diagram.\n\t * Does not include UI elements for controlling the machine.\n\t *\n\t * @module\n\t */\n\t\n\tvar TuringMachine = __webpack_require__(11).TuringMachine,\n\t    TapeViz = __webpack_require__(51),\n\t    StateGraph = __webpack_require__(48),\n\t    StateViz = __webpack_require__(49),\n\t    watchInit = __webpack_require__(16).watchInit,\n\t    d3 = __webpack_require__(2);\n\t\n\t/**\n\t * Create an animated transition function.\n\t * @param  {StateGraph} graph\n\t * @param  {LayoutEdge -> any} animationCallback\n\t * @return {(string, string) -> Instruction} Created transition function.\n\t */\n\tfunction animatedTransition(graph, animationCallback) {\n\t  return function (state, symbol) {\n\t    var tuple = graph.getInstructionAndEdge(state, symbol);\n\t    if (tuple == null) { return null; }\n\t\n\t    animationCallback(tuple.edge);\n\t    return tuple.instruction;\n\t  };\n\t}\n\t\n\t/**\n\t * Default edge animation callback.\n\t * @param  {{domNode: Node}} edge\n\t * @return {D3Transition} The animation. Use this for transition chaining.\n\t */\n\tfunction pulseEdge(edge) {\n\t  var edgepath = d3.select(edge.domNode);\n\t  return edgepath\n\t      .classed('active-edge', true)\n\t    .transition()\n\t      .style('stroke-width', '3px')\n\t    .transition()\n\t      .style('stroke-width', '1px')\n\t    .transition()\n\t      .duration(0)\n\t      .each('start', /* @this edge */ function () {\n\t        d3.select(this).classed('active-edge', false);\n\t      })\n\t      .style('stroke', null)\n\t      .style('stroke-width', null);\n\t}\n\t\n\tfunction addTape(div, spec) {\n\t  return new TapeViz(div.append('svg').attr('class', 'tm-tape'), 9,\n\t    spec.blank, spec.input ? String(spec.input).split('') : []);\n\t}\n\t\n\t/**\n\t * Construct a new state and tape visualization inside a &lt;div&gt;.\n\t * @constructor\n\t * @param {HTMLDivElement} div        div to take over and use.\n\t * @param                  spec       machine specification\n\t * @param {PositionTable} [posTable]  position table for the state nodes\n\t */\n\tfunction TMViz(div, spec, posTable) {\n\t  div = d3.select(div);\n\t  var graph = new StateGraph(spec.table);\n\t  this.stateviz = new StateViz(\n\t    div,\n\t    graph.getVertexMap(),\n\t    graph.getEdges()\n\t  );\n\t  if (posTable != undefined) { this.positionTable = posTable; }\n\t\n\t  this.edgeAnimation = pulseEdge;\n\t  this.stepInterval = 100;\n\t\n\t  var self = this;\n\t  // We hook into the animation callback to know when to start the next step (when running).\n\t  function animateAndContinue(edge) {\n\t    var transition = self.edgeAnimation(edge);\n\t    if (self.isRunning) {\n\t      transition.transition().duration(self.stepInterval).each('end', function () {\n\t        // stop if machine was paused during the animation\n\t        if (self.isRunning) { self.step(); }\n\t      });\n\t    }\n\t  }\n\t\n\t  this.machine = new TuringMachine(\n\t    animatedTransition(graph, animateAndContinue),\n\t    spec.startState,\n\t    addTape(div, spec),\n\t    spec.startIndex\n\t  );\n\t  // intercept and animate when the state is set\n\t  watchInit(this.machine, 'state', function (prop, oldstate, newstate) {\n\t    d3.select(graph.getVertex(oldstate).domNode).classed('current-state', false);\n\t    d3.select(graph.getVertex(newstate).domNode).classed('current-state', true);\n\t    return newstate;\n\t  });\n\t\n\t  // Sidenote: each \"Step\" click evaluates the transition function once.\n\t  // Therefore, detecting halting always requires its own step (for consistency).\n\t  this.isHalted = false;\n\t\n\t  var isRunning = false;\n\t  /**\n\t   * Set isRunning to true to run the machine, and false to stop it.\n\t   */\n\t  Object.defineProperty(this, 'isRunning', {\n\t    configurable: true,\n\t    get: function () { return isRunning; },\n\t    set: function (value) {\n\t      if (isRunning !== value) {\n\t        isRunning = value;\n\t        if (isRunning) { this.step(); }\n\t      }\n\t    }\n\t  });\n\t\n\t  this.__parentDiv = div;\n\t  this.__spec = spec;\n\t}\n\t\n\t/**\n\t * Step the machine immediately and interrupt any animations.\n\t */\n\tTMViz.prototype.step = function () {\n\t  if (!this.machine.step()) {\n\t    this.isRunning = false;\n\t    this.isHalted = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Reset the Turing machine to its starting configuration.\n\t */\n\tTMViz.prototype.reset = function () {\n\t  this.isRunning = false;\n\t  this.isHalted = false;\n\t  this.machine.state = this.__spec.startState;\n\t  this.machine.tape.domNode.remove();\n\t  this.machine.tape = addTape(this.__parentDiv, this.__spec);\n\t};\n\t\n\tObject.defineProperty(TMViz.prototype, 'positionTable', {\n\t  get: function ()  { return this.stateviz.positionTable; },\n\t  set: function (posTable) { this.stateviz.positionTable = posTable; }\n\t});\n\t\n\tmodule.exports = TMViz;\n\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Construct a Turing machine.\n\t * @param {(state, symbol) -> ?{state: state, symbol: symbol, move: direction}}\n\t *   transition\n\t *   A transition function that, given *only* the current state and symbol,\n\t *   returns an object with the following properties: symbol, move, and state.\n\t *   Returning null/undefined halts the machine (no transition defined).\n\t * @param {state} startState  The state to start in.\n\t * @param         tape        The tape to use.\n\t * @param {int} startPosition The index to start in\n\t */\n\tfunction TuringMachine(transition, startState, tape, startPosition) {\n\t  this.transition = transition;\n\t  this.state = startState;\n\t  this.tape = tape;\n\t  this.startPosition = startPosition;\n\t  for (var i = 0; i < startPosition; i++) {\n\t    this.tape.headRight();\n\t  }\n\t}\n\t\n\tTuringMachine.prototype.toString = function () {\n\t  return String(this.state) + '\\n' + String(this.tape);\n\t};\n\t\n\t/**\n\t * Step to the next configuration according to the transition function.\n\t * @return {boolean} true if successful (the transition is defined),\n\t *   false otherwise (machine halted)\n\t */\n\tTuringMachine.prototype.step = function () {\n\t  var instruct = this.nextInstruction;\n\t  if (instruct == null) { return false; }\n\t  console.log(this.tape.tape.toString() + '   ' + this.state + '   ' + this.tape.read() + ' → ' + '(' + instruct.symbol + ',' + instruct.move  + ')' );\n\t  this.tape.write(instruct.symbol);\n\t  move(this.tape, instruct.move);\n\t  this.state = instruct.state;\n\t\n\t  return true;\n\t};\n\t\n\tObject.defineProperties(TuringMachine.prototype, {\n\t  nextInstruction: {\n\t    get: function () { return this.transition(this.state, this.tape.read()); },\n\t    enumerable: true\n\t  },\n\t  isHalted: {\n\t    get: function () { return this.nextInstruction == null; },\n\t    enumerable: true\n\t  }\n\t});\n\t\n\t// Allows for both notational conventions of moving the head or moving the tape\n\tfunction move(tape, direction) {\n\t  switch (direction) {\n\t    case MoveHead.right: tape.headRight(); break;\n\t    case MoveHead.neutral: break;\n\t    case MoveHead.left: tape.headLeft(); break;\n\t    default: throw new TypeError('not a valid tape movement: ' + String(direction));\n\t  }\n\t}\n\tvar MoveHead = Object.freeze({\n\t  left: { toString: function () { return 'L'; } },\n\t  right: { toString: function () { return 'R'; } },\n\t  neutral: { toString: function () { return 'N'; } }\n\t});\n\tvar MoveTape = Object.freeze({ left: MoveHead.right, right: MoveHead.left, neutral: MoveHead.neutral });\n\t\n\texports.MoveHead = MoveHead;\n\texports.MoveTape = MoveTape;\n\texports.TuringMachine = TuringMachine;\n\n\n/***/ }),\n\n/***/ 16:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Lightweight property assignment watching by overriding getters/setters.\n\t * Intended as a bridge between plain JS properties and other libraries.\n\t *\n\t * Inspired by https://gist.github.com/eligrey/384583, which works for\n\t * data properties only, this works for both data and accessor properties.\n\t *\n\t * 2015-11-21\n\t * @author Andy Li\n\t */\n\t\n\t/**\n\t * Watches a property for assignment by overriding it with a getter & setter\n\t * on top of the previous value or accessors.\n\t *\n\t * The handler can intercept assignments by returning a different value.\n\t * Watching an unwritable/unsettable property does nothing, but trying to watch\n\t * a non-existent or non-configurable property fails fast with TypeError.\n\t * @param  {!Object} thisArg The object that contains the property.\n\t * @param  {String}  prop    The name of the property to watch.\n\t * @param            handler The function to call when the property is\n\t *   assigned to. Important: this function intercepts assignment;\n\t *   its return value is set as the new value.\n\t * @throws {TypeError} if object is null or does not have the property\n\t * @throws {TypeError} if thisArg.prop is non-configurable\n\t * @return {?Object}         The previous property descriptor, or null if the\n\t *   property is not writable/settable.\n\t */\n\tfunction watch(thisArg, prop, handler) {\n\t  var desc = Object.getOwnPropertyDescriptor(thisArg, prop);\n\t  // check pre-conditions: existent, configurable, writable/settable\n\t  if (desc === undefined) {\n\t    throw new TypeError('Cannot watch nonexistent property \\''+prop+'\\'');\n\t  } else if (!desc.configurable) {\n\t    throw new TypeError('Cannot watch non-configurable property \\''+prop+'\\'');\n\t  } else if (!desc.writable && desc.set === undefined) {\n\t    return; // no-op since property can't change without reconfiguration\n\t  }\n\t\n\t  var accessors = (function () {\n\t    if (desc.set) {\n\t      // case: .get/.set\n\t      return {\n\t        get: desc.get,\n\t        set: function (newval) {\n\t          return desc.set.call(thisArg, handler.call(thisArg, prop, thisArg[prop], newval));\n\t        }\n\t      };\n\t    } else {\n\t      // case: .value\n\t      var val = desc.value;\n\t      return {\n\t        get: function () {\n\t          return val;\n\t        },\n\t        set: function (newval) {\n\t          return val = handler.call(thisArg, prop, val, newval);\n\t        }\n\t      };\n\t    }\n\t  })();\n\t  Object.defineProperty(thisArg, prop, accessors);\n\t\n\t  return desc;\n\t}\n\t\n\t/**\n\t * {@link watch} that, if successful, also calls the handler once with\n\t *   the current value (by setting it).\n\t * @see watch\n\t */\n\tfunction watchInit(thisArg, prop, handler) {\n\t  var value = thisArg[prop];\n\t  var desc = watch(thisArg, prop, handler);\n\t  if (desc) { thisArg[prop] = value; }\n\t  return desc;\n\t}\n\t\n\tif (true) {\n\t  exports.watch = watch;\n\t  exports.watchInit = watchInit;\n\t}\n\n\n/***/ }),\n\n/***/ 19:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"state-diagram/StateViz.css\";\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"tape/tape.css\";\n\n/***/ }),\n\n/***/ 48:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\t\n\t\n\t/* Interface\n\t  type TransitionTable = {\n\t    [state: string]: ?{\n\t      [symbol: string]: Instruction\n\t    }\n\t  };\n\t  type Instruction = { state?: string, symbol?: string };\n\t\n\t  type DiagramGraph = {\n\t    [state: string]: {\n\t      label: string,\n\t      transitions: ?{\n\t        [symbol: string]: {\n\t          instruction: Instruction,\n\t          edge: LayoutEdge\n\t        }\n\t      }\n\t    }\n\t  };\n\t  type LayoutEdge = { source: Object, target: Object, labels: [string] }\n\t */\n\t\n\t/**\n\t * Use a transition table to derive the graph (vertices & edges) for a D3 diagram.\n\t * Edges with the same source and target are combined.\n\t * NB. In addition to single symbols, comma-separated symbols are supported.\n\t * e.g. symbol string '0,1,,,I' -> symbols [0,1,',','I'].\n\t */\n\t// TransitionTable -> DiagramGraph\n\tfunction deriveGraph(table) {\n\t  // We need two passes, since edges may point at vertices yet to be created.\n\t  // 1. Create all the vertices.\n\t  var graph = _.mapValues(table, function (transitions, state) {\n\t    return {\n\t      label: state,\n\t      transitions: transitions\n\t    };\n\t  });\n\t  // 2. Create the edges, which can now point at any vertex object.\n\t  var allEdges = [];\n\t  _.forEach(graph, function (vertex, state) {\n\t\n\t    vertex.transitions = vertex.transitions && (function () {\n\t      var stateTransitions = {};\n\t\n\t      // Combine edges with the same source and target\n\t      var cache = {};\n\t      function edgeTo(target, label) {\n\t        var edge = cache[target] ||\n\t          _.tap(cache[target] = {\n\t            source: vertex,\n\t            target: graph[target],\n\t            labels: []\n\t          }, allEdges.push.bind(allEdges));\n\t        edge.labels.push(label);\n\t        return edge;\n\t      }\n\t      // Create symbol -> instruction object map\n\t      _.forEach(vertex.transitions, function (instruct, symbolKey) {\n\t        // Handle comma-separated symbols.\n\t        // Recreate array by splitting on ','. Treat 2 consecutive ',' as , ','.\n\t        var symbols = symbolKey.split(',').reduce(function (acc, x) {\n\t          if (x === '' && acc[acc.length-1] === '') {\n\t            acc[acc.length-1] = ',';\n\t          } else {\n\t            acc.push(x);\n\t          }\n\t          return acc;\n\t        }, []);\n\t        var target = instruct.state != null ? instruct.state : state;\n\t        var edge = edgeTo(target, labelFor(symbols, instruct));\n\t\n\t        symbols.forEach(function (symbol) {\n\t          stateTransitions[symbol] = {\n\t            // Normalize for execution, but display the less-cluttered original.\n\t            instruction: normalize(state, symbol, instruct),\n\t            edge: edge\n\t          };\n\t        });\n\t      });\n\t\n\t      return stateTransitions;\n\t    }());\n\t\n\t  });\n\t\n\t  return {graph: graph, edges: allEdges};\n\t}\n\t\n\t// Normalize an instruction to include an explicit state and symbol.\n\t// e.g. {symbol: '1'} normalizes to {state: 'q0', symbol: '1'} when in state q0.\n\tfunction normalize(state, symbol, instruction) {\n\t  return _.defaults({}, instruction, {state: state, symbol: symbol});\n\t}\n\t\n\tfunction labelFor(symbols, action) {\n\t  var rightSide = ((action.symbol == null) ? '' : (visibleSpace(String(action.symbol)) + ','))\n\t    + String(action.move);\n\t  return symbols.map(visibleSpace).join(',') + '→' + rightSide;\n\t}\n\t\n\t// replace ' ' with '␣'.\n\tfunction visibleSpace(c) {\n\t  return (c === ' ') ? '␣' : c;\n\t}\n\t\n\t\n\t/**\n\t * Aids rendering and animating a transition table in D3.\n\t *\n\t * • Generates the vertices and edges (\"nodes\" and \"links\") for a D3 diagram.\n\t * • Provides mapping of each state to its vertex and each transition to its edge.\n\t * @param {TransitionTable} table\n\t */\n\tfunction StateGraph(table) {\n\t  var derived = deriveGraph(table);\n\t  Object.defineProperties(this, {\n\t    __graph: { value: derived.graph },\n\t    __edges: { value: derived.edges }\n\t  });\n\t}\n\t\n\t/**\n\t * D3 layout \"nodes\".\n\t */\n\t// StateGraph.prototype.getVertices = function () {\n\t//   return _.values(this.__graph);\n\t// };\n\t\n\t/**\n\t * Returns the mapping from states to vertices (D3 layout \"nodes\").\n\t * @return { {[state: string]: Object} }\n\t */\n\tStateGraph.prototype.getVertexMap = function () {\n\t  return this.__graph;\n\t};\n\t\n\t/**\n\t * D3 layout \"links\".\n\t */\n\tStateGraph.prototype.getEdges = function () {\n\t  return this.__edges;\n\t};\n\t\n\t/**\n\t * Look up a state's corresponding D3 \"node\".\n\t */\n\tStateGraph.prototype.getVertex = function (state) {\n\t  return this.__graph[state];\n\t};\n\t\n\tStateGraph.prototype.getInstructionAndEdge = function (state, symbol) {\n\t  var vertex = this.__graph[state];\n\t  if (vertex === undefined) {\n\t    throw new Error('not a valid state: ' + String(state));\n\t  }\n\t\n\t  return vertex.transitions && vertex.transitions[symbol];\n\t};\n\t\n\t\n\tmodule.exports = StateGraph;\n\n\n/***/ }),\n\n/***/ 49:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isBrowserIEorEdge = __webpack_require__(3).isBrowserIEorEdge;\n\tvar d3 = __webpack_require__(2);\n\tvar _ = __webpack_require__(1);\n\tvar assign = __webpack_require__(6).assign; // need mutable assign()\n\t\n\t// *** Arrays as vectors ***\n\t\n\t// Add vectors.\n\t// Note: dimensions are not checked. Missing dimensions become NaN.\n\tfunction addV(array1, array2) {\n\t  return array1.map(function (x, i) { return x + array2[i]; });\n\t}\n\t\n\tfunction negateV(array) {\n\t  return array.map(function (x) { return -x; });\n\t}\n\t\n\tfunction subtractV(array1, array2) {\n\t  return addV(array1, negateV(array2));\n\t}\n\t\n\t// Scale the vector by a scalar.\n\tfunction multiplyV(array, scalar) {\n\t  return array.map(function (x) { return scalar*x; });\n\t}\n\t\n\t// Vector norm, squared\n\tfunction normSqV(array) {\n\t  function sq(x) { return x*x; }\n\t  function add(x, y) { return x + y; }\n\t  return array.map(sq).reduce(add, 0);\n\t}\n\t\n\t// Vector norm\n\tfunction normV(array) { return Math.sqrt(normSqV(array)); }\n\t\n\t// Return a copy of the vector rescaled as a unit vector (norm = 1).\n\tfunction unitV(array) {\n\t  var n = normV(array);\n\t  return array.map(function (x) { return x / n; });\n\t}\n\t\n\t// *** 2D Vectors ***\n\tfunction angleV(array) {\n\t  var x = array[0], y = array[1];\n\t  return Math.atan2(y, x);\n\t}\n\t\n\tfunction vectorFromLengthAngle(length, angle) {\n\t  return [Math.cos(angle) * length, Math.sin(angle) * length];\n\t}\n\t\n\t// *** Utilities ***\n\t\n\t// Count the directed edges that start at a given node and end at another.\n\t// Important: each node must have a unique .index property.\n\t// Example usage:\n\t// var counts = new EdgeCounter(edges);\n\t// var edgesFrom2To5 = counts.numEdgesFromTo(2,5);\n\t// var edgesFrom5to2 = counts.numEdgesFromTo(5,2);\n\tfunction EdgeCounter(edges) {\n\t  edges.forEach(function (e) {\n\t    var key = e.source.index +','+ e.target.index;\n\t    this[key] = (this[key] || 0) + 1;\n\t  }, this);\n\t}\n\t\n\tEdgeCounter.prototype.numEdgesFromTo = function (src, target) {\n\t  return this[String(src)+','+String(target)] || 0;\n\t};\n\t\n\tvar EdgeShape = Object.freeze({\n\t  loop: {},     // self-loop: a->a\n\t  arc: {},      // curved arc: a->b when b->a exists\n\t  straight: {}  // straight edge: a->b when b->a does not exist\n\t});\n\t\n\tEdgeCounter.prototype.shapeForEdge = function (e) {\n\t  if (e.target.index === e.source.index) {\n\t    return EdgeShape.loop;\n\t  } else if (this.numEdgesFromTo(e.target.index, e.source.index)) {\n\t    // has returning edge => arc\n\t    return EdgeShape.arc;\n\t  } else {\n\t    return EdgeShape.straight;\n\t  }\n\t};\n\t\n\t// create a function that will compute an edge's SVG 'd' attribute.\n\tfunction edgePathFor(nodeRadius, shape, d) {\n\t  // case: self-loop\n\t  var loopEndOffset, loopArc;\n\t  if (shape === EdgeShape.loop) {\n\t    // start at the top (90°), end slightly above the right (15°)\n\t    loopEndOffset = vectorFromLengthAngle(nodeRadius, -15 * Math.PI/180);\n\t    loopArc = ' a 19,27 45 1,1 ' + loopEndOffset[0] + ',' + (loopEndOffset[1]+nodeRadius);\n\t    return function () {\n\t      var x1 = d.source.x,\n\t          y1 = d.source.y;\n\t      return 'M ' + x1 + ',' + (y1-nodeRadius) + loopArc;\n\t    };\n\t  }\n\t  // case: between nodes\n\t  if (shape === EdgeShape.arc) {\n\t    // sub-case: arc\n\t    return function () {\n\t      // note: p1 & p2 have to be delayed, to access x/y at the time of the call\n\t      var p1 = [d.source.x, d.source.y];\n\t      var p2 = [d.target.x, d.target.y];\n\t      var offset = subtractV(p2, p1);\n\t      var radius = 6/5*normV(offset);\n\t      // Note: SVG's y-axis is flipped, so vector angles are negative\n\t      // relative to standard coordinates (as used in Math.atan2).\n\t      // Proof: angle(r <cos ϴ, -sin ϴ>) = angle(r <cos -ϴ, sin -ϴ>) = -ϴ.\n\t      var angle = angleV(offset);\n\t      var sep = -Math.PI/2/2; // 90° separation, half on each side\n\t      var source = addV(p1, vectorFromLengthAngle(nodeRadius, angle+sep));\n\t      var target = addV(p2, vectorFromLengthAngle(nodeRadius, angle+Math.PI-sep));\n\t      // IDEA: consider http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands\n\t      return (p1[0] <= p2[0])\n\t        ? 'M '+source[0]+' '+source[1]+' A '+radius+' '+radius+' 0 0,1 '+target[0]+' '+target[1]\n\t        : 'M '+target[0]+' '+target[1]+' A '+radius+' '+radius+' 0 0,0 '+source[0]+' '+source[1];\n\t    };\n\t  } else if (shape === EdgeShape.straight) {\n\t    return function () {\n\t      // sub-case: straight line\n\t      var p1 = [d.source.x, d.source.y];\n\t      var p2 = [d.target.x, d.target.y];\n\t      var offset = subtractV(p2, p1);\n\t      // avoid spurious errors when bounding causes node centers to coincide\n\t      if (offset[0] === 0 && offset[1] === 0) { return null; }\n\t\n\t      var target = subtractV(p2, multiplyV(unitV(offset), nodeRadius));\n\t      return 'M '+p1[0]+' '+p1[1]+' L '+ target[0] +' '+ target[1];\n\t    };\n\t  }\n\t}\n\t\n\tfunction rectCenter(svgrect) {\n\t  return {x: svgrect.x + svgrect.width/2,\n\t          y: svgrect.y + svgrect.height/2};\n\t}\n\t\n\tfunction identity(x) { return x; }\n\tfunction noop() {}\n\t\n\tfunction limitRange(min, max, value) {\n\t  return Math.max(min, Math.min(value, max));\n\t}\n\t\n\t// IE padding hack so that SVG resizes properly.\n\t// This works across browsers but we only need it for IE.\n\tvar appendSVGTo = !isBrowserIEorEdge\n\t  ? function (div) { return div.append('svg'); }\n\t  : function (div, hwRatio) {\n\t    return div\n\t      .append('div')\n\t        .style({\n\t          width: '100%',\n\t          height: '0',\n\t          'padding-bottom': (100 * hwRatio) + '%',\n\t          position: 'relative'\n\t        })\n\t      .append('svg')\n\t        .style({\n\t          position: 'absolute',\n\t          top: '0',\n\t          left: '0'\n\t        });\n\t  };\n\t\n\t// *** D3 diagram ***\n\t__webpack_require__(19);\n\t\n\t// type LayoutNode = {label: string};\n\t// type StateMap = {[state: string]: LayoutNode};\n\t\n\t/**\n\t * Create a state diagram inside an SVG.\n\t * Each vertex/edge (node/link) object is also annotated with @.domNode@\n\t * corresponding to its SVG element.\n\t *\n\t * Note: currently, element IDs (e.g. for textPath) will collide if multiple\n\t * diagrams are on the same document (HTML page).\n\t * @param  {D3Selection}      container     Container to add the SVG to.\n\t * @param  {[LayoutNode] | StateMap} nodes  Parameter to D3's force.nodes.\n\t *   Important: passing a StateMap is recommended when using setPositionTable.\n\t *   Passing an array will key the state nodes by array index.\n\t * @param  {[LayoutEdge]}     linkArray     Parameter to D3's force.links.\n\t */\n\tfunction StateViz(container, nodes, linkArray) {\n\t  /* References:\n\t    [Sticky Force Layout](http://bl.ocks.org/mbostock/3750558) demonstrates\n\t    drag to position and double-click to release.\n\t\n\t    [Graph with labeled edges](http://bl.ocks.org/jhb/5955887) demonstrates\n\t    arrow edges with auto-rotated labels.\n\t  */\n\t\n\t  /* eslint-disable no-invalid-this */ // eslint is not familiar with D3\n\t  var w = 800;\n\t  var h = 500;\n\t  var linkDistance = 140;\n\t  var nodeRadius = 20;\n\t\n\t  var colors = d3.scale.category10();\n\t\n\t  var svg = appendSVGTo(container, h/w);\n\t  svg.attr({\n\t    'viewBox': [0, 0, w, h].join(' '),\n\t    'version': '1.1',\n\t    ':xmlns': 'http://www.w3.org/2000/svg',\n\t    ':xmlns:xlink': 'http://www.w3.org/1999/xlink'\n\t  });\n\t\n\t  // Force Layout\n\t\n\t  // drag event handlers\n\t  function dragstart(d) {\n\t    d.fixed = true;\n\t    svg.transition()\n\t      .style('box-shadow', 'inset 0 0 1px gold');\n\t  }\n\t  function dragend() {\n\t    svg.transition()\n\t      .style('box-shadow', null);\n\t  }\n\t  function releasenode(d) {\n\t    d.fixed = false;\n\t    force.resume();\n\t  }\n\t\n\t  // set up force layout\n\t  var nodeArray = nodes instanceof Array ? nodes : _.values(nodes);\n\t  this.__stateMap = nodes;\n\t\n\t  var force = d3.layout.force()\n\t      .nodes(nodeArray)\n\t      .links(linkArray)\n\t      .size([w,h])\n\t      .linkDistance([linkDistance])\n\t      .charge([-500])\n\t      .theta(0.1)\n\t      .gravity(0.05)\n\t      .start();\n\t\n\t  var drag = force.drag()\n\t      .on('dragstart', dragstart)\n\t      .on('dragend', dragend);\n\t\n\t  // Edges\n\t  var edgeCounter = new EdgeCounter(linkArray);\n\t\n\t  var edgeselection = svg.selectAll('.edgepath')\n\t    .data(linkArray)\n\t    .enter();\n\t\n\t  var edgegroups = edgeselection.append('g');\n\t\n\t  var labelAbove = function (d, i) { return String(-1.1*(i+1)) + 'em'; };\n\t  var labelBelow = function (d, i) { return String(0.6+ 1.1*(i+1)) + 'em'; };\n\t\n\t  edgegroups.each(function (edgeD, edgeIndex) {\n\t    var group = d3.select(this);\n\t    var edgepath = group\n\t      .append('path')\n\t        .attr({'class': 'edgepath',\n\t               'id': 'edgepath'+edgeIndex })\n\t        .each(function (d) { d.domNode = this; });\n\t    var byTarget = {};\n\t    edgeD.labels.forEach(function (label) {\n\t      var pieces = label.split('→');\n\t      if (byTarget[pieces[1]] == undefined) {\n\t        byTarget[pieces[1]] = [];\n\t      }\n\t      byTarget[pieces[1]].push(pieces[0]);\n\t    });\n\t\n\t    var edgeLabels = [];\n\t    Object.keys(byTarget).forEach(function (key) {\n\t      if (edgeD.source == edgeD.target && key.length == 1) {\n\t        edgeLabels.push(key);\n\t      } else {\n\t        edgeLabels.push(byTarget[key].join(',') + '→' + key);\n\t      }\n\t    });\n\t\n\t    var labels = group.selectAll('.edgelabel')\n\t      .data(edgeLabels).enter()\n\t      .append('text')\n\t        .attr('class', 'edgelabel');\n\t    labels.append('textPath')\n\t        .attr('xlink:href', function () { return '#edgepath'+edgeIndex; })\n\t        .attr('startOffset', '50%')\n\t        .text(identity);\n\t    /* To reduce JS computation, label positioning varies by edge shape:\n\t        * Straight edges can use a fixed 'dy' value.\n\t        * Loops cannot use 'dy' since it increases letter spacing\n\t          as labels get farther from the path. Instead, since a loop's shape\n\t          is fixed, it allows a fixed translate 'transform'.\n\t        * Arcs are bent and their shape is not fixed, so neither 'dy'\n\t          nor 'transform' can be constant.\n\t          Fortunately the curvature is slight enough that a fixed 'dy'\n\t          looks good enough without resorting to dynamic translations.\n\t    */\n\t    var shape = edgeCounter.shapeForEdge(edgeD);\n\t    edgeD.getPath = edgePathFor(nodeRadius, shape, edgeD);\n\t    switch (shape) {\n\t      case EdgeShape.straight:\n\t        labels.attr('dy', labelAbove);\n\t        edgeD.refreshLabels = function () {\n\t          // flip edge labels that are upside-down\n\t          labels.attr('transform', function () {\n\t            if (edgeD.target.x < edgeD.source.x) {\n\t              var c = rectCenter(this.getBBox());\n\t              return 'rotate(180 '+c.x+' '+c.y+')';\n\t            } else {\n\t              return null;\n\t            }\n\t          });\n\t        };\n\t        break;\n\t      case EdgeShape.arc:\n\t        var isFlipped;\n\t        edgeD.refreshLabels = function () {\n\t          var shouldFlip = edgeD.target.x < edgeD.source.x;\n\t          if (shouldFlip !== isFlipped) {\n\t            edgepath.classed('reversed-arc', shouldFlip);\n\t            labels.attr('dy', shouldFlip ? labelBelow : labelAbove);\n\t            isFlipped = shouldFlip;\n\t          }\n\t        };\n\t        break;\n\t      case EdgeShape.loop:\n\t        labels.attr('transform', function (d, i) {\n\t          return 'translate(' + String(8*(i+1)) + ' ' + String(-8*(i+1)) + ')';\n\t        });\n\t        edgeD.refreshLabels = noop;\n\t        break;\n\t    }\n\t  });\n\t  var edgepaths = edgegroups.selectAll('.edgepath');\n\t\n\t  // Nodes\n\t  // note: nodes are added after edges so as to paint over excess edge lines\n\t  var nodeSelection = svg.selectAll('.node')\n\t    .data(nodeArray)\n\t    .enter();\n\t\n\t  var nodecircles = nodeSelection\n\t    .append('circle')\n\t      .attr('class', 'node')\n\t      .attr('r', nodeRadius)\n\t      .style('fill', function (d,i) { return colors(i); })\n\t      .each(function (d) { d.domNode = this; })\n\t      .on('dblclick', releasenode)\n\t      .call(drag);\n\t\n\t  var nodelabels = nodeSelection\n\t   .append('text')\n\t     .attr('class', 'nodelabel')\n\t     .attr('dy', '0.25em') /* dy doesn't work in CSS */\n\t     .text(function (d) { return d.label; });\n\t\n\t  // Arrowheads\n\t  var svgdefs = svg.append('defs');\n\t  svgdefs.selectAll('marker')\n\t      .data(['arrowhead', 'active-arrowhead', 'reversed-arrowhead', 'reversed-active-arrowhead'])\n\t    .enter().append('marker')\n\t      .attr({'id': function (d) { return d; },\n\t             'viewBox':'0 -5 10 10',\n\t             'refX': function (d) {\n\t               return (d.lastIndexOf('reversed-', 0) === 0) ? 0 : 10;\n\t             },\n\t             'orient':'auto',\n\t             'markerWidth':10,\n\t             'markerHeight':10\n\t            })\n\t    .append('path')\n\t      .attr('d', 'M 0 -5 L 10 0 L 0 5 Z')\n\t      .attr('transform', function (d) {\n\t        return (d.lastIndexOf('reversed-', 0) === 0) ? 'rotate(180 5 0)' : null;\n\t      });\n\t\n\t  var svgCSS =\n\t    '.edgepath {' +\n\t    '  marker-end: url(#arrowhead);' +\n\t    '}' +\n\t    '.edgepath.active-edge {' +\n\t    '  marker-end: url(#active-arrowhead);' +\n\t    '}' +\n\t    '.edgepath.reversed-arc {' +\n\t    '  marker-start: url(#reversed-arrowhead);' +\n\t    '  marker-end: none;' +\n\t    '}' +\n\t    '.edgepath.active-edge.reversed-arc {' +\n\t    '  marker-start: url(#reversed-active-arrowhead);' +\n\t    '  marker-end: none;' +\n\t    '}';\n\t  svg.append('style').each(function () {\n\t    if (this.styleSheet) {\n\t      this.styleSheet.cssText = svgCSS;\n\t    } else {\n\t      this.textContent = svgCSS;\n\t    }\n\t  });\n\t\n\t  // Force Layout Update\n\t  force.on('tick', function () {\n\t    // Keep coordinates in bounds. http://bl.ocks.org/mbostock/1129492\n\t    // NB. Bounding can cause node centers to coincide, especially at corners.\n\t    nodecircles.attr({cx: function (d) { return d.x = limitRange(nodeRadius, w - nodeRadius, d.x); },\n\t                      cy: function (d) { return d.y = limitRange(nodeRadius, h - nodeRadius, d.y); }\n\t    });\n\t\n\t    nodelabels.attr('x', function (d) { return d.x; })\n\t              .attr('y', function (d) { return d.y; });\n\t\n\t    edgepaths.attr('d', function (d) { return d.getPath(); });\n\t\n\t    edgegroups.each(function (d) { d.refreshLabels(); });\n\t\n\t    // Conserve CPU when layout is fully fixed\n\t    if (nodeArray.every(function (d) { return d.fixed; })) {\n\t      force.stop();\n\t    }\n\t  });\n\t  this.force = force;\n\t  /* eslint-enable no-invalid-this */\n\t}\n\t\n\t// Positioning\n\t\n\t// {[key: State]: Node} -> PositionTable\n\tvar getPositionTable = _.mapValues(_.pick(['x', 'y', 'px', 'py', 'fixed']));\n\t\n\t// Tag nodes w/ positions. Mutates the node map.\n\t// PositionTable -> {[key: State]: Node} -> void\n\tfunction setPositionTable(posTable, stateMap) {\n\t  _.forEach(function (node, state) {\n\t    var position = posTable[state];\n\t    if (position !== undefined) {\n\t      assign(node, position);\n\t    }\n\t  }, stateMap);\n\t}\n\t\n\tObject.defineProperty(StateViz.prototype, 'positionTable', {\n\t  get: function () { return getPositionTable(this.__stateMap); },\n\t  set: function (posTable) {\n\t    setPositionTable(posTable, this.__stateMap);\n\t    // ensure that a cooled layout will update\n\t    this.force.resume();\n\t  }\n\t});\n\t\n\t\n\tmodule.exports = StateViz;\n\n\n/***/ }),\n\n/***/ 50:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar _ = __webpack_require__(1);\n\t\n\t/*\n\t * supported unicode variants\n\t *\n\t * m: monospace\n\t * b: bold\n\t * i: italic\n\t * c: script\n\t * g: gothic / fraktur\n\t * d: double-struck\n\t * s: sans-serif\n\t * o: circled text\n\t * p: parenthesized latin letters\n\t * w: fullwidth\n\t */\n\t\n\tfunction toUnicodeVariant(str, variant, flags) {\n\t\n\t  var offsets = {\n\t    m: [0x1d670, 0x1d7f6],\n\t    b: [0x1d400, 0x1d7ce],\n\t    i: [0x1d434, 0x00030],\n\t    bi: [0x1d468, 0x00030],\n\t    c: [0x1d49c, 0x00030],\n\t    bc: [0x1d4d0, 0x00030],\n\t    g: [0x1d504, 0x00030],\n\t    d: [0x1d538, 0x1d7d8],\n\t    bg: [0x1d56c, 0x00030],\n\t    s: [0x1d5a0, 0x1d7e2],\n\t    bs: [0x1d5d4, 0x1d7ec],\n\t    is: [0x1d608, 0x00030],\n\t    bis: [0x1d63c, 0x00030],\n\t    o: [0x24B6, 0x2460],\n\t    p: [0x249C, 0x2474],\n\t    w: [0xff21, 0xff10],\n\t    u: [0x2090, 0xff10]\n\t  };\n\t\n\t  var variantOffsets = {\n\t    'monospace': 'm',\n\t    'bold' : 'b',\n\t    'italic' : 'i',\n\t    'bold italic' : 'bi',\n\t    'script': 'c',\n\t    'bold script': 'bc',\n\t    'gothic': 'g',\n\t    'gothic bold': 'bg',\n\t    'doublestruck': 'd',\n\t    'sans': 's',\n\t    'bold sans' : 'bs',\n\t    'italic sans': 'is',\n\t    'bold italic sans': 'bis',\n\t    'parenthesis': 'p',\n\t    'circled': 'o',\n\t    'fullwidth': 'w'\n\t  };\n\t\n\t  // special characters (absolute values)\n\t  var special = {\n\t    m: {\n\t      ' ': 0x2000,\n\t      '-': 0x2013\n\t    },\n\t    i: {\n\t      'h': 0x210e\n\t    },\n\t    g: {\n\t      'C': 0x212d,\n\t      'H': 0x210c,\n\t      'I': 0x2111,\n\t      'R': 0x211c,\n\t      'Z': 0x2128\n\t    },\n\t    o: {\n\t      '0': 0x24EA,\n\t      '1': 0x2460,\n\t      '2': 0x2461,\n\t      '3': 0x2462,\n\t      '4': 0x2463,\n\t      '5': 0x2464,\n\t      '6': 0x2465,\n\t      '7': 0x2466,\n\t      '8': 0x2467,\n\t      '9': 0x2468,\n\t    },\n\t    p: {},\n\t    w: {}\n\t  };\n\t  //support for parenthesized latin letters small cases\n\t  for (var i = 97; i <= 122; i++) {\n\t    special.p[String.fromCharCode(i)] = 0x249C + (i-97);\n\t  }\n\t  //support for full width latin letters small cases\n\t  for (i = 97; i <= 122; i++) {\n\t    special.w[String.fromCharCode(i)] = 0xff41 + (i-97);\n\t  }\n\t\n\t  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\t  var numbers = '0123456789';\n\t\n\t  var getType = function (variantt) {\n\t    if (variantOffsets[variantt]) return variantOffsets[variantt];\n\t    if (offsets[variantt]) return variantt;\n\t    return 'm'; //monospace as default\n\t  };\n\t  var getFlag = function (flag, flagz) {\n\t    if (!flagz) return false;\n\t    return flagz.split(',').indexOf(flag)>-1;\n\t  };\n\t\n\t  var type = getType(variant);\n\t  var underline = getFlag('underline', flags);\n\t  var strike = getFlag('strike', flags);\n\t  var result = '';\n\t\n\t  for (i = 0; i < str.length; i++) {\n\t    var k = str.charAt(i);\n\t    var index;\n\t    var c = k;\n\t    if (special[type] && special[type][c]) c = String.fromCodePoint(special[type][c]);\n\t    if (type && (index = chars.indexOf(c)) > -1) {\n\t      result += String.fromCodePoint(index + offsets[type][0]);\n\t    } else if (type && (index = numbers.indexOf(c)) > -1) {\n\t      result += String.fromCodePoint(index + offsets[type][1]);\n\t    } else {\n\t      result += c;\n\t    }\n\t    if (underline) result += '\\u0332'; // add combining underline\n\t    if (strike) result += '\\u0336'; // add combining strike\n\t  }\n\t  return result;\n\t}\n\t\n\t// Bidirectional infinite tape\n\tfunction Tape(blank, input) {\n\t  Object.defineProperty(this, 'blank', {\n\t    value: blank,\n\t    writable: false,\n\t    enumerable: true\n\t  });\n\t  // zipper data structure\n\t  // INVARIANTS: tape.before can be empty, tape.after must be nonempty.\n\t  // before: cells before the head (in order; left to right).\n\t  // after:  cells after and including the head (in reverse; right to left).\n\t  this.tape = {\n\t    before: [],\n\t    after: (input == null || input.length == 0) ? [blank] : input.slice().reverse(),\n\t    toString: function () {\n\t      return this.before.join('') + toUnicodeVariant(_.last(this.after), 'circled') + this.after.slice(0, this.after.length-1).reverse().join('');\n\t    }\n\t  };\n\t}\n\t\n\t// Read the value at the tape head.\n\tTape.prototype.read = function () {\n\t  return _.last(this.tape.after);\n\t};\n\tTape.prototype.write = function (symbol) {\n\t  this.tape.after[this.tape.after.length - 1] = symbol;\n\t};\n\t\n\tTape.prototype.headRight = function () {\n\t  var before = this.tape.before,\n\t      after = this.tape.after;\n\t  before.push(after.pop());\n\t  if (_.isEmpty(after)) {\n\t    after.push(this.blank);\n\t  }\n\t};\n\tTape.prototype.headLeft = function () {\n\t  var before = this.tape.before,\n\t      after = this.tape.after;\n\t  if (_.isEmpty(before)) {\n\t    before.push(this.blank);\n\t  }\n\t  after.push(before.pop());\n\t};\n\t\n\tTape.prototype.toString = function () {\n\t  return this.tape.toString();\n\t};\n\t\n\t// for tape visualization. not part of TM definition.\n\t// Read the value at an offset from the tape head.\n\t// 0 is the tape head. + is to the right, - to the left.\n\tTape.prototype.readOffset = function (i) {\n\t  var tape = this.tape;\n\t  if (i >= 0) {\n\t    // right side: offset [0..length-1] ↦ array index [length-1..0]\n\t    return (i <= tape.after.length - 1) ? tape.after[tape.after.length - 1 - i] : this.blank;\n\t  } else {\n\t    // left side: offset [-1..-length] ↦ array index [length-1..0]\n\t    return (i >= -tape.before.length) ? tape.before[tape.before.length + i] : this.blank;\n\t  }\n\t};\n\t\n\t// for tape visualization.\n\t// Read the values from an offset range (inclusive of start and end).\n\tTape.prototype.readRange = function (start, end) {\n\t  return _.range(start, end+1).map(function (i) {\n\t    return this.readOffset(i);\n\t  }, this);\n\t};\n\t\n\tmodule.exports = Tape;\n\n\n/***/ }),\n\n/***/ 51:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar Tape = __webpack_require__(50),\n\t    d3   = __webpack_require__(2);\n\t__webpack_require__(20);\n\t\n\tvar cellWidth = 50;\n\tvar cellHeight = 50;\n\t\n\tfunction initTapeCells(selection) {\n\t  selection.attr('class', 'tape-cell');\n\t  selection.append('rect')\n\t      // the box outline is purely visual, so remove its data binding\n\t      .datum(null)\n\t      .attr({'width': cellWidth,\n\t             'height': cellHeight});\n\t  selection.append('text')\n\t      .text(function (d) { return d; })\n\t      .attr({'x': cellWidth/2, 'y': cellHeight/2 + 8});\n\t  return selection;\n\t}\n\t\n\tfunction positionCells(selection, offset) {\n\t  offset = (offset == null) ? 0 : offset;\n\t  selection.attr('transform', function (d, i) {\n\t    return 'translate(' + (-cellWidth+10 + cellWidth*(i+offset)) + ')';\n\t  });\n\t  return selection;\n\t}\n\t\n\tfunction repositionWrapper(wrapper) {\n\t  wrapper.attr('transform', 'translate(0 10)')\n\t    .transition()\n\t      .duration(0)\n\t    .select('.exiting')\n\t      .remove();\n\t}\n\t\n\t// Tape visualization centered around the tape head.\n\tfunction TapeViz(svg, lookaround, blank, input) {\n\t  Tape.call(this, blank, input);\n\t\n\t  Object.defineProperty(this, 'lookaround', {\n\t    value: lookaround,\n\t    writable: false,\n\t    enumerable: true\n\t  });\n\t  Object.defineProperty(this, 'domNode', {\n\t    value: svg,\n\t    writable: false,\n\t    enumerable: true\n\t  });\n\t\n\t  // width is before + head + after, trimming 2 off to show cut-off tape ends\n\t  var width  = cellWidth * (lookaround+1+lookaround-2) + 2*10;\n\t  var height = cellHeight + 2*10;\n\t  svg.attr({\n\t    'width': '95%',\n\t    'viewBox': [0, 0, width, height].join(' ')\n\t  });\n\t\n\t  this.wrapper = svg.append('g')\n\t      .attr('class', 'wrapper')\n\t      .call(repositionWrapper);\n\t\n\t  svg.append('rect')\n\t      .attr({'id': 'tape-head',\n\t             'width': (1+1/5) * cellWidth,\n\t             'height': (1+1/5) * cellHeight,\n\t             'x': -cellWidth+10/2 + cellWidth*lookaround,\n\t             'y': 10/2\n\t           });\n\t\n\t  this.wrapper.selectAll('.tape-cell')\n\t      .data(this.readRange(-lookaround, lookaround))\n\t    .enter()\n\t    .append('g')\n\t      .call(initTapeCells)\n\t      .call(positionCells)\n\t  ;\n\t}\n\t\n\tTapeViz.prototype = Object.create(Tape.prototype);\n\tTapeViz.prototype.constructor = TapeViz;\n\t\n\t// IDEA: chain headLeft/Right to wait for write()?\n\tTapeViz.prototype.write = function (symbol) {\n\t  // don't animate if symbol stays the same\n\t  if (Tape.prototype.read.call(this) === symbol) {\n\t    return;\n\t  }\n\t  Tape.prototype.write.call(this, symbol);\n\t\n\t  // remove leftover .exiting in case animation was interrupted\n\t  this.wrapper.selectAll('.exiting').remove();\n\t\n\t  d3.select(this.wrapper[0][0].childNodes[this.lookaround])\n\t      .datum(symbol)\n\t    .select('text')\n\t      .attr('fill-opacity', '1')\n\t      .attr('stroke-opacity', '1')\n\t    .transition()\n\t      .attr('fill-opacity', '0.4')\n\t      .attr('stroke-opacity', '0.1')\n\t    .transition()\n\t      .text(function (d) { return d; })\n\t      .attr('fill-opacity', '1')\n\t      .attr('stroke-opacity', '1')\n\t    .transition()\n\t      .duration(0)\n\t      .attr('fill-opacity', null)\n\t      .attr('stroke-opacity', null)\n\t    ;\n\t};\n\t\n\tfunction moveHead(wrapper, enter, exit, wOffset, cOffset) {\n\t  // add to one end\n\t  enter.call(initTapeCells);\n\t  // remove from the other end\n\t  exit.classed('exiting', true);\n\t  // translate cells forward, and the wrapper backwards\n\t  wrapper.selectAll('.tape-cell')\n\t      .call(positionCells, cOffset);\n\t  wrapper\n\t      .attr('transform', 'translate(' + (wOffset*cellWidth).toString() + ' 10)')\n\t    // animate wrapper returning to neutral position\n\t    .transition()\n\t      .call(repositionWrapper);\n\t}\n\t\n\tTapeViz.prototype.headRight = function () {\n\t  Tape.prototype.headRight.call(this);\n\t  // remove leftover .exiting in case animation was interrupted.\n\t  // Important: call-by-value evaluates the selection argument(s) of 'moveHead' before\n\t  // before entering the function, so exiting nodes have to be removed beforehand.\n\t  this.wrapper.selectAll('.exiting').remove();\n\t  moveHead(this.wrapper,\n\t    // add to right end\n\t    this.wrapper.append('g')\n\t        .datum(this.readOffset(this.lookaround)),\n\t    // remove from left end\n\t    this.wrapper.select('.tape-cell'),\n\t    1, -1);\n\t};\n\t\n\tTapeViz.prototype.headLeft = function () {\n\t  Tape.prototype.headLeft.call(this);\n\t  this.wrapper.selectAll('.exiting').remove();\n\t  moveHead(this.wrapper,\n\t    this.wrapper.insert('g', ':first-child')\n\t        .datum(this.readOffset(-this.lookaround)),\n\t    this.wrapper.select('.wrapper > .tape-cell:last-of-type'),\n\t    -1, 0);\n\t};\n\t\n\tmodule.exports = TapeViz;\n\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// TMViz.bundle.js"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp_name_\"];\n \twindow[\"webpackJsonp_name_\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"1\":\"main\"}[chunkId]||chunkId) + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cdd1786ab9de02b253e8","module.exports = _;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"_\"\n// module id = 1\n// module chunks = 0","module.exports = d3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3\"\n// module id = 2\n// module chunks = 0","'use strict';\n// misc. utilities\n\n//////////////////////////////////\n// Utilities for null/undefined //\n//////////////////////////////////\n\n// Assert non-null.\n// Return the value if it is not null or undefined; otherwise, throw an error.\nfunction nonNull(value) {\n  if (value == null) {\n    throw new Error('expected a non-null defined value, but got: ' + String(value));\n  }\n  return value;\n}\n\n// Null coalescing: iff the first argument is null or undefined, return the second.\nfunction coalesce(a, b) {\n  return (a != null) ? a : b;\n}\n\n// Apply a function to a value if non-null, otherwise return the value.\n// (Monadic bind for maybe (option) type.)\n// ((a -> b), ?a) -> ?b\nfunction applyMaybe(f, x) {\n  return (x != null) ? f(x) : x;\n}\n\n// Returns the first function result that is not null or undefined.\n// Otherwise, returns undefined.\n// ((a -> ?b), [a]) -> ?b\nfunction getFirst(f, xs) {\n  for (var i = 0; i < xs.length; ++i) {\n    var val = f(xs[i]);\n    if (val != null) {\n      return val;\n    }\n  }\n}\n\n/////////\n// DOM //\n/////////\n\n/* global document */\n\n/**\n * Concat an array of DOM Nodes into a DocumentFragment.\n * @param  {[Node]} array\n * @return {DocumentFragment}\n */\nfunction toDocFragment(array) {\n  var result = document.createDocumentFragment();\n  array.forEach(result.appendChild.bind(result));\n  return result;\n}\n\n///////////////////////\n// IE/Edge detection //\n///////////////////////\n\n// http://stackoverflow.com/a/9851769\nvar isBrowserIEorEdge = /*@cc_on!@*/false\n  || Boolean(document.documentMode) || Boolean(window.StyleMedia); // eslint-disable-line\n\n\nexports.nonNull = nonNull;\nexports.coalesce = coalesce;\nexports.applyMaybe = applyMaybe;\nexports.getFirst = getFirst;\n\nexports.toDocFragment = toDocFragment;\n\nexports.isBrowserIEorEdge = isBrowserIEorEdge;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util.js\n// module id = 3\n// module chunks = 0","module.exports = lodash;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 6\n// module chunks = 0","'use strict';\n/**\n * Turing machine visualization component.\n *\n * • Adds running and reset on top of the base Turing machine.\n * • Displays an animated state diagram and tape diagram.\n * Does not include UI elements for controlling the machine.\n *\n * @module\n */\n\nvar TuringMachine = require('./TuringMachine').TuringMachine,\n    TapeViz = require('./tape/TapeViz'),\n    StateGraph = require('./state-diagram/StateGraph'),\n    StateViz = require('./state-diagram/StateViz'),\n    watchInit = require('./watch').watchInit,\n    d3 = require('d3');\n\n/**\n * Create an animated transition function.\n * @param  {StateGraph} graph\n * @param  {LayoutEdge -> any} animationCallback\n * @return {(string, string) -> Instruction} Created transition function.\n */\nfunction animatedTransition(graph, animationCallback) {\n  return function (state, symbol) {\n    var tuple = graph.getInstructionAndEdge(state, symbol);\n    if (tuple == null) { return null; }\n\n    animationCallback(tuple.edge);\n    return tuple.instruction;\n  };\n}\n\n/**\n * Default edge animation callback.\n * @param  {{domNode: Node}} edge\n * @return {D3Transition} The animation. Use this for transition chaining.\n */\nfunction pulseEdge(edge) {\n  var edgepath = d3.select(edge.domNode);\n  return edgepath\n      .classed('active-edge', true)\n    .transition()\n      .style('stroke-width', '3px')\n    .transition()\n      .style('stroke-width', '1px')\n    .transition()\n      .duration(0)\n      .each('start', /* @this edge */ function () {\n        d3.select(this).classed('active-edge', false);\n      })\n      .style('stroke', null)\n      .style('stroke-width', null);\n}\n\nfunction addTape(div, spec) {\n  return new TapeViz(div.append('svg').attr('class', 'tm-tape'), 9,\n    spec.blank, spec.input ? String(spec.input).split('') : []);\n}\n\n/**\n * Construct a new state and tape visualization inside a &lt;div&gt;.\n * @constructor\n * @param {HTMLDivElement} div        div to take over and use.\n * @param                  spec       machine specification\n * @param {PositionTable} [posTable]  position table for the state nodes\n */\nfunction TMViz(div, spec, posTable) {\n  div = d3.select(div);\n  var graph = new StateGraph(spec.table);\n  this.stateviz = new StateViz(\n    div,\n    graph.getVertexMap(),\n    graph.getEdges()\n  );\n  if (posTable != undefined) { this.positionTable = posTable; }\n\n  this.edgeAnimation = pulseEdge;\n  this.stepInterval = 100;\n\n  var self = this;\n  // We hook into the animation callback to know when to start the next step (when running).\n  function animateAndContinue(edge) {\n    var transition = self.edgeAnimation(edge);\n    if (self.isRunning) {\n      transition.transition().duration(self.stepInterval).each('end', function () {\n        // stop if machine was paused during the animation\n        if (self.isRunning) { self.step(); }\n      });\n    }\n  }\n\n  this.machine = new TuringMachine(\n    animatedTransition(graph, animateAndContinue),\n    spec.startState,\n    addTape(div, spec),\n    spec.startIndex\n  );\n  // intercept and animate when the state is set\n  watchInit(this.machine, 'state', function (prop, oldstate, newstate) {\n    d3.select(graph.getVertex(oldstate).domNode).classed('current-state', false);\n    d3.select(graph.getVertex(newstate).domNode).classed('current-state', true);\n    return newstate;\n  });\n\n  // Sidenote: each \"Step\" click evaluates the transition function once.\n  // Therefore, detecting halting always requires its own step (for consistency).\n  this.isHalted = false;\n\n  var isRunning = false;\n  /**\n   * Set isRunning to true to run the machine, and false to stop it.\n   */\n  Object.defineProperty(this, 'isRunning', {\n    configurable: true,\n    get: function () { return isRunning; },\n    set: function (value) {\n      if (isRunning !== value) {\n        isRunning = value;\n        if (isRunning) { this.step(); }\n      }\n    }\n  });\n\n  this.__parentDiv = div;\n  this.__spec = spec;\n}\n\n/**\n * Step the machine immediately and interrupt any animations.\n */\nTMViz.prototype.step = function () {\n  if (!this.machine.step()) {\n    this.isRunning = false;\n    this.isHalted = true;\n  }\n};\n\n/**\n * Reset the Turing machine to its starting configuration.\n */\nTMViz.prototype.reset = function () {\n  this.isRunning = false;\n  this.isHalted = false;\n  this.machine.state = this.__spec.startState;\n  this.machine.tape.domNode.remove();\n  this.machine.tape = addTape(this.__parentDiv, this.__spec);\n};\n\nObject.defineProperty(TMViz.prototype, 'positionTable', {\n  get: function ()  { return this.stateviz.positionTable; },\n  set: function (posTable) { this.stateviz.positionTable = posTable; }\n});\n\nmodule.exports = TMViz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TMViz.js\n// module id = 10\n// module chunks = 0","'use strict';\n/**\n * Construct a Turing machine.\n * @param {(state, symbol) -> ?{state: state, symbol: symbol, move: direction}}\n *   transition\n *   A transition function that, given *only* the current state and symbol,\n *   returns an object with the following properties: symbol, move, and state.\n *   Returning null/undefined halts the machine (no transition defined).\n * @param {state} startState  The state to start in.\n * @param         tape        The tape to use.\n * @param {int} startPosition The index to start in\n */\nfunction TuringMachine(transition, startState, tape, startPosition) {\n  this.transition = transition;\n  this.state = startState;\n  this.tape = tape;\n  this.startPosition = startPosition;\n  for (var i = 0; i < startPosition; i++) {\n    this.tape.headRight();\n  }\n}\n\nTuringMachine.prototype.toString = function () {\n  return String(this.state) + '\\n' + String(this.tape);\n};\n\n/**\n * Step to the next configuration according to the transition function.\n * @return {boolean} true if successful (the transition is defined),\n *   false otherwise (machine halted)\n */\nTuringMachine.prototype.step = function () {\n  var instruct = this.nextInstruction;\n  if (instruct == null) { return false; }\n  console.log(this.tape.tape.toString() + '   ' + this.state + '   ' + this.tape.read() + ' → ' + '(' + instruct.symbol + ',' + instruct.move  + ')' );\n  this.tape.write(instruct.symbol);\n  move(this.tape, instruct.move);\n  this.state = instruct.state;\n\n  return true;\n};\n\nObject.defineProperties(TuringMachine.prototype, {\n  nextInstruction: {\n    get: function () { return this.transition(this.state, this.tape.read()); },\n    enumerable: true\n  },\n  isHalted: {\n    get: function () { return this.nextInstruction == null; },\n    enumerable: true\n  }\n});\n\n// Allows for both notational conventions of moving the head or moving the tape\nfunction move(tape, direction) {\n  switch (direction) {\n    case MoveHead.right: tape.headRight(); break;\n    case MoveHead.neutral: break;\n    case MoveHead.left: tape.headLeft(); break;\n    default: throw new TypeError('not a valid tape movement: ' + String(direction));\n  }\n}\nvar MoveHead = Object.freeze({\n  left: { toString: function () { return 'L'; } },\n  right: { toString: function () { return 'R'; } },\n  neutral: { toString: function () { return 'N'; } }\n});\nvar MoveTape = Object.freeze({ left: MoveHead.right, right: MoveHead.left, neutral: MoveHead.neutral });\n\nexports.MoveHead = MoveHead;\nexports.MoveTape = MoveTape;\nexports.TuringMachine = TuringMachine;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/TuringMachine.js\n// module id = 11\n// module chunks = 0","'use strict';\n/**\n * Lightweight property assignment watching by overriding getters/setters.\n * Intended as a bridge between plain JS properties and other libraries.\n *\n * Inspired by https://gist.github.com/eligrey/384583, which works for\n * data properties only, this works for both data and accessor properties.\n *\n * 2015-11-21\n * @author Andy Li\n */\n\n/**\n * Watches a property for assignment by overriding it with a getter & setter\n * on top of the previous value or accessors.\n *\n * The handler can intercept assignments by returning a different value.\n * Watching an unwritable/unsettable property does nothing, but trying to watch\n * a non-existent or non-configurable property fails fast with TypeError.\n * @param  {!Object} thisArg The object that contains the property.\n * @param  {String}  prop    The name of the property to watch.\n * @param            handler The function to call when the property is\n *   assigned to. Important: this function intercepts assignment;\n *   its return value is set as the new value.\n * @throws {TypeError} if object is null or does not have the property\n * @throws {TypeError} if thisArg.prop is non-configurable\n * @return {?Object}         The previous property descriptor, or null if the\n *   property is not writable/settable.\n */\nfunction watch(thisArg, prop, handler) {\n  var desc = Object.getOwnPropertyDescriptor(thisArg, prop);\n  // check pre-conditions: existent, configurable, writable/settable\n  if (desc === undefined) {\n    throw new TypeError('Cannot watch nonexistent property \\''+prop+'\\'');\n  } else if (!desc.configurable) {\n    throw new TypeError('Cannot watch non-configurable property \\''+prop+'\\'');\n  } else if (!desc.writable && desc.set === undefined) {\n    return; // no-op since property can't change without reconfiguration\n  }\n\n  var accessors = (function () {\n    if (desc.set) {\n      // case: .get/.set\n      return {\n        get: desc.get,\n        set: function (newval) {\n          return desc.set.call(thisArg, handler.call(thisArg, prop, thisArg[prop], newval));\n        }\n      };\n    } else {\n      // case: .value\n      var val = desc.value;\n      return {\n        get: function () {\n          return val;\n        },\n        set: function (newval) {\n          return val = handler.call(thisArg, prop, val, newval);\n        }\n      };\n    }\n  })();\n  Object.defineProperty(thisArg, prop, accessors);\n\n  return desc;\n}\n\n/**\n * {@link watch} that, if successful, also calls the handler once with\n *   the current value (by setting it).\n * @see watch\n */\nfunction watchInit(thisArg, prop, handler) {\n  var value = thisArg[prop];\n  var desc = watch(thisArg, prop, handler);\n  if (desc) { thisArg[prop] = value; }\n  return desc;\n}\n\nif (typeof exports === 'object') {\n  exports.watch = watch;\n  exports.watchInit = watchInit;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/watch.js\n// module id = 16\n// module chunks = 0","module.exports = __webpack_public_path__ + \"state-diagram/StateViz.css\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateViz.css\n// module id = 19\n// module chunks = 0","module.exports = __webpack_public_path__ + \"tape/tape.css\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/tape.css\n// module id = 20\n// module chunks = 0","'use strict';\n\nvar _ = require('lodash');\n\n\n/* Interface\n  type TransitionTable = {\n    [state: string]: ?{\n      [symbol: string]: Instruction\n    }\n  };\n  type Instruction = { state?: string, symbol?: string };\n\n  type DiagramGraph = {\n    [state: string]: {\n      label: string,\n      transitions: ?{\n        [symbol: string]: {\n          instruction: Instruction,\n          edge: LayoutEdge\n        }\n      }\n    }\n  };\n  type LayoutEdge = { source: Object, target: Object, labels: [string] }\n */\n\n/**\n * Use a transition table to derive the graph (vertices & edges) for a D3 diagram.\n * Edges with the same source and target are combined.\n * NB. In addition to single symbols, comma-separated symbols are supported.\n * e.g. symbol string '0,1,,,I' -> symbols [0,1,',','I'].\n */\n// TransitionTable -> DiagramGraph\nfunction deriveGraph(table) {\n  // We need two passes, since edges may point at vertices yet to be created.\n  // 1. Create all the vertices.\n  var graph = _.mapValues(table, function (transitions, state) {\n    return {\n      label: state,\n      transitions: transitions\n    };\n  });\n  // 2. Create the edges, which can now point at any vertex object.\n  var allEdges = [];\n  _.forEach(graph, function (vertex, state) {\n\n    vertex.transitions = vertex.transitions && (function () {\n      var stateTransitions = {};\n\n      // Combine edges with the same source and target\n      var cache = {};\n      function edgeTo(target, label) {\n        var edge = cache[target] ||\n          _.tap(cache[target] = {\n            source: vertex,\n            target: graph[target],\n            labels: []\n          }, allEdges.push.bind(allEdges));\n        edge.labels.push(label);\n        return edge;\n      }\n      // Create symbol -> instruction object map\n      _.forEach(vertex.transitions, function (instruct, symbolKey) {\n        // Handle comma-separated symbols.\n        // Recreate array by splitting on ','. Treat 2 consecutive ',' as , ','.\n        var symbols = symbolKey.split(',').reduce(function (acc, x) {\n          if (x === '' && acc[acc.length-1] === '') {\n            acc[acc.length-1] = ',';\n          } else {\n            acc.push(x);\n          }\n          return acc;\n        }, []);\n        var target = instruct.state != null ? instruct.state : state;\n        var edge = edgeTo(target, labelFor(symbols, instruct));\n\n        symbols.forEach(function (symbol) {\n          stateTransitions[symbol] = {\n            // Normalize for execution, but display the less-cluttered original.\n            instruction: normalize(state, symbol, instruct),\n            edge: edge\n          };\n        });\n      });\n\n      return stateTransitions;\n    }());\n\n  });\n\n  return {graph: graph, edges: allEdges};\n}\n\n// Normalize an instruction to include an explicit state and symbol.\n// e.g. {symbol: '1'} normalizes to {state: 'q0', symbol: '1'} when in state q0.\nfunction normalize(state, symbol, instruction) {\n  return _.defaults({}, instruction, {state: state, symbol: symbol});\n}\n\nfunction labelFor(symbols, action) {\n  var rightSide = ((action.symbol == null) ? '' : (visibleSpace(String(action.symbol)) + ','))\n    + String(action.move);\n  return symbols.map(visibleSpace).join(',') + '→' + rightSide;\n}\n\n// replace ' ' with '␣'.\nfunction visibleSpace(c) {\n  return (c === ' ') ? '␣' : c;\n}\n\n\n/**\n * Aids rendering and animating a transition table in D3.\n *\n * • Generates the vertices and edges (\"nodes\" and \"links\") for a D3 diagram.\n * • Provides mapping of each state to its vertex and each transition to its edge.\n * @param {TransitionTable} table\n */\nfunction StateGraph(table) {\n  var derived = deriveGraph(table);\n  Object.defineProperties(this, {\n    __graph: { value: derived.graph },\n    __edges: { value: derived.edges }\n  });\n}\n\n/**\n * D3 layout \"nodes\".\n */\n// StateGraph.prototype.getVertices = function () {\n//   return _.values(this.__graph);\n// };\n\n/**\n * Returns the mapping from states to vertices (D3 layout \"nodes\").\n * @return { {[state: string]: Object} }\n */\nStateGraph.prototype.getVertexMap = function () {\n  return this.__graph;\n};\n\n/**\n * D3 layout \"links\".\n */\nStateGraph.prototype.getEdges = function () {\n  return this.__edges;\n};\n\n/**\n * Look up a state's corresponding D3 \"node\".\n */\nStateGraph.prototype.getVertex = function (state) {\n  return this.__graph[state];\n};\n\nStateGraph.prototype.getInstructionAndEdge = function (state, symbol) {\n  var vertex = this.__graph[state];\n  if (vertex === undefined) {\n    throw new Error('not a valid state: ' + String(state));\n  }\n\n  return vertex.transitions && vertex.transitions[symbol];\n};\n\n\nmodule.exports = StateGraph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateGraph.js\n// module id = 48\n// module chunks = 0","'use strict';\n\nvar isBrowserIEorEdge = require('../util').isBrowserIEorEdge;\nvar d3 = require('d3');\nvar _ = require('lodash/fp');\nvar assign = require('lodash').assign; // need mutable assign()\n\n// *** Arrays as vectors ***\n\n// Add vectors.\n// Note: dimensions are not checked. Missing dimensions become NaN.\nfunction addV(array1, array2) {\n  return array1.map(function (x, i) { return x + array2[i]; });\n}\n\nfunction negateV(array) {\n  return array.map(function (x) { return -x; });\n}\n\nfunction subtractV(array1, array2) {\n  return addV(array1, negateV(array2));\n}\n\n// Scale the vector by a scalar.\nfunction multiplyV(array, scalar) {\n  return array.map(function (x) { return scalar*x; });\n}\n\n// Vector norm, squared\nfunction normSqV(array) {\n  function sq(x) { return x*x; }\n  function add(x, y) { return x + y; }\n  return array.map(sq).reduce(add, 0);\n}\n\n// Vector norm\nfunction normV(array) { return Math.sqrt(normSqV(array)); }\n\n// Return a copy of the vector rescaled as a unit vector (norm = 1).\nfunction unitV(array) {\n  var n = normV(array);\n  return array.map(function (x) { return x / n; });\n}\n\n// *** 2D Vectors ***\nfunction angleV(array) {\n  var x = array[0], y = array[1];\n  return Math.atan2(y, x);\n}\n\nfunction vectorFromLengthAngle(length, angle) {\n  return [Math.cos(angle) * length, Math.sin(angle) * length];\n}\n\n// *** Utilities ***\n\n// Count the directed edges that start at a given node and end at another.\n// Important: each node must have a unique .index property.\n// Example usage:\n// var counts = new EdgeCounter(edges);\n// var edgesFrom2To5 = counts.numEdgesFromTo(2,5);\n// var edgesFrom5to2 = counts.numEdgesFromTo(5,2);\nfunction EdgeCounter(edges) {\n  edges.forEach(function (e) {\n    var key = e.source.index +','+ e.target.index;\n    this[key] = (this[key] || 0) + 1;\n  }, this);\n}\n\nEdgeCounter.prototype.numEdgesFromTo = function (src, target) {\n  return this[String(src)+','+String(target)] || 0;\n};\n\nvar EdgeShape = Object.freeze({\n  loop: {},     // self-loop: a->a\n  arc: {},      // curved arc: a->b when b->a exists\n  straight: {}  // straight edge: a->b when b->a does not exist\n});\n\nEdgeCounter.prototype.shapeForEdge = function (e) {\n  if (e.target.index === e.source.index) {\n    return EdgeShape.loop;\n  } else if (this.numEdgesFromTo(e.target.index, e.source.index)) {\n    // has returning edge => arc\n    return EdgeShape.arc;\n  } else {\n    return EdgeShape.straight;\n  }\n};\n\n// create a function that will compute an edge's SVG 'd' attribute.\nfunction edgePathFor(nodeRadius, shape, d) {\n  // case: self-loop\n  var loopEndOffset, loopArc;\n  if (shape === EdgeShape.loop) {\n    // start at the top (90°), end slightly above the right (15°)\n    loopEndOffset = vectorFromLengthAngle(nodeRadius, -15 * Math.PI/180);\n    loopArc = ' a 19,27 45 1,1 ' + loopEndOffset[0] + ',' + (loopEndOffset[1]+nodeRadius);\n    return function () {\n      var x1 = d.source.x,\n          y1 = d.source.y;\n      return 'M ' + x1 + ',' + (y1-nodeRadius) + loopArc;\n    };\n  }\n  // case: between nodes\n  if (shape === EdgeShape.arc) {\n    // sub-case: arc\n    return function () {\n      // note: p1 & p2 have to be delayed, to access x/y at the time of the call\n      var p1 = [d.source.x, d.source.y];\n      var p2 = [d.target.x, d.target.y];\n      var offset = subtractV(p2, p1);\n      var radius = 6/5*normV(offset);\n      // Note: SVG's y-axis is flipped, so vector angles are negative\n      // relative to standard coordinates (as used in Math.atan2).\n      // Proof: angle(r <cos ϴ, -sin ϴ>) = angle(r <cos -ϴ, sin -ϴ>) = -ϴ.\n      var angle = angleV(offset);\n      var sep = -Math.PI/2/2; // 90° separation, half on each side\n      var source = addV(p1, vectorFromLengthAngle(nodeRadius, angle+sep));\n      var target = addV(p2, vectorFromLengthAngle(nodeRadius, angle+Math.PI-sep));\n      // IDEA: consider http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands\n      return (p1[0] <= p2[0])\n        ? 'M '+source[0]+' '+source[1]+' A '+radius+' '+radius+' 0 0,1 '+target[0]+' '+target[1]\n        : 'M '+target[0]+' '+target[1]+' A '+radius+' '+radius+' 0 0,0 '+source[0]+' '+source[1];\n    };\n  } else if (shape === EdgeShape.straight) {\n    return function () {\n      // sub-case: straight line\n      var p1 = [d.source.x, d.source.y];\n      var p2 = [d.target.x, d.target.y];\n      var offset = subtractV(p2, p1);\n      // avoid spurious errors when bounding causes node centers to coincide\n      if (offset[0] === 0 && offset[1] === 0) { return null; }\n\n      var target = subtractV(p2, multiplyV(unitV(offset), nodeRadius));\n      return 'M '+p1[0]+' '+p1[1]+' L '+ target[0] +' '+ target[1];\n    };\n  }\n}\n\nfunction rectCenter(svgrect) {\n  return {x: svgrect.x + svgrect.width/2,\n          y: svgrect.y + svgrect.height/2};\n}\n\nfunction identity(x) { return x; }\nfunction noop() {}\n\nfunction limitRange(min, max, value) {\n  return Math.max(min, Math.min(value, max));\n}\n\n// IE padding hack so that SVG resizes properly.\n// This works across browsers but we only need it for IE.\nvar appendSVGTo = !isBrowserIEorEdge\n  ? function (div) { return div.append('svg'); }\n  : function (div, hwRatio) {\n    return div\n      .append('div')\n        .style({\n          width: '100%',\n          height: '0',\n          'padding-bottom': (100 * hwRatio) + '%',\n          position: 'relative'\n        })\n      .append('svg')\n        .style({\n          position: 'absolute',\n          top: '0',\n          left: '0'\n        });\n  };\n\n// *** D3 diagram ***\nrequire('./StateViz.css');\n\n// type LayoutNode = {label: string};\n// type StateMap = {[state: string]: LayoutNode};\n\n/**\n * Create a state diagram inside an SVG.\n * Each vertex/edge (node/link) object is also annotated with @.domNode@\n * corresponding to its SVG element.\n *\n * Note: currently, element IDs (e.g. for textPath) will collide if multiple\n * diagrams are on the same document (HTML page).\n * @param  {D3Selection}      container     Container to add the SVG to.\n * @param  {[LayoutNode] | StateMap} nodes  Parameter to D3's force.nodes.\n *   Important: passing a StateMap is recommended when using setPositionTable.\n *   Passing an array will key the state nodes by array index.\n * @param  {[LayoutEdge]}     linkArray     Parameter to D3's force.links.\n */\nfunction StateViz(container, nodes, linkArray) {\n  /* References:\n    [Sticky Force Layout](http://bl.ocks.org/mbostock/3750558) demonstrates\n    drag to position and double-click to release.\n\n    [Graph with labeled edges](http://bl.ocks.org/jhb/5955887) demonstrates\n    arrow edges with auto-rotated labels.\n  */\n\n  /* eslint-disable no-invalid-this */ // eslint is not familiar with D3\n  var w = 800;\n  var h = 500;\n  var linkDistance = 140;\n  var nodeRadius = 20;\n\n  var colors = d3.scale.category10();\n\n  var svg = appendSVGTo(container, h/w);\n  svg.attr({\n    'viewBox': [0, 0, w, h].join(' '),\n    'version': '1.1',\n    ':xmlns': 'http://www.w3.org/2000/svg',\n    ':xmlns:xlink': 'http://www.w3.org/1999/xlink'\n  });\n\n  // Force Layout\n\n  // drag event handlers\n  function dragstart(d) {\n    d.fixed = true;\n    svg.transition()\n      .style('box-shadow', 'inset 0 0 1px gold');\n  }\n  function dragend() {\n    svg.transition()\n      .style('box-shadow', null);\n  }\n  function releasenode(d) {\n    d.fixed = false;\n    force.resume();\n  }\n\n  // set up force layout\n  var nodeArray = nodes instanceof Array ? nodes : _.values(nodes);\n  this.__stateMap = nodes;\n\n  var force = d3.layout.force()\n      .nodes(nodeArray)\n      .links(linkArray)\n      .size([w,h])\n      .linkDistance([linkDistance])\n      .charge([-500])\n      .theta(0.1)\n      .gravity(0.05)\n      .start();\n\n  var drag = force.drag()\n      .on('dragstart', dragstart)\n      .on('dragend', dragend);\n\n  // Edges\n  var edgeCounter = new EdgeCounter(linkArray);\n\n  var edgeselection = svg.selectAll('.edgepath')\n    .data(linkArray)\n    .enter();\n\n  var edgegroups = edgeselection.append('g');\n\n  var labelAbove = function (d, i) { return String(-1.1*(i+1)) + 'em'; };\n  var labelBelow = function (d, i) { return String(0.6+ 1.1*(i+1)) + 'em'; };\n\n  edgegroups.each(function (edgeD, edgeIndex) {\n    var group = d3.select(this);\n    var edgepath = group\n      .append('path')\n        .attr({'class': 'edgepath',\n               'id': 'edgepath'+edgeIndex })\n        .each(function (d) { d.domNode = this; });\n    var byTarget = {};\n    edgeD.labels.forEach(function (label) {\n      var pieces = label.split('→');\n      if (byTarget[pieces[1]] == undefined) {\n        byTarget[pieces[1]] = [];\n      }\n      byTarget[pieces[1]].push(pieces[0]);\n    });\n\n    var edgeLabels = [];\n    Object.keys(byTarget).forEach(function (key) {\n      if (edgeD.source == edgeD.target && key.length == 1) {\n        edgeLabels.push(key);\n      } else {\n        edgeLabels.push(byTarget[key].join(',') + '→' + key);\n      }\n    });\n\n    var labels = group.selectAll('.edgelabel')\n      .data(edgeLabels).enter()\n      .append('text')\n        .attr('class', 'edgelabel');\n    labels.append('textPath')\n        .attr('xlink:href', function () { return '#edgepath'+edgeIndex; })\n        .attr('startOffset', '50%')\n        .text(identity);\n    /* To reduce JS computation, label positioning varies by edge shape:\n        * Straight edges can use a fixed 'dy' value.\n        * Loops cannot use 'dy' since it increases letter spacing\n          as labels get farther from the path. Instead, since a loop's shape\n          is fixed, it allows a fixed translate 'transform'.\n        * Arcs are bent and their shape is not fixed, so neither 'dy'\n          nor 'transform' can be constant.\n          Fortunately the curvature is slight enough that a fixed 'dy'\n          looks good enough without resorting to dynamic translations.\n    */\n    var shape = edgeCounter.shapeForEdge(edgeD);\n    edgeD.getPath = edgePathFor(nodeRadius, shape, edgeD);\n    switch (shape) {\n      case EdgeShape.straight:\n        labels.attr('dy', labelAbove);\n        edgeD.refreshLabels = function () {\n          // flip edge labels that are upside-down\n          labels.attr('transform', function () {\n            if (edgeD.target.x < edgeD.source.x) {\n              var c = rectCenter(this.getBBox());\n              return 'rotate(180 '+c.x+' '+c.y+')';\n            } else {\n              return null;\n            }\n          });\n        };\n        break;\n      case EdgeShape.arc:\n        var isFlipped;\n        edgeD.refreshLabels = function () {\n          var shouldFlip = edgeD.target.x < edgeD.source.x;\n          if (shouldFlip !== isFlipped) {\n            edgepath.classed('reversed-arc', shouldFlip);\n            labels.attr('dy', shouldFlip ? labelBelow : labelAbove);\n            isFlipped = shouldFlip;\n          }\n        };\n        break;\n      case EdgeShape.loop:\n        labels.attr('transform', function (d, i) {\n          return 'translate(' + String(8*(i+1)) + ' ' + String(-8*(i+1)) + ')';\n        });\n        edgeD.refreshLabels = noop;\n        break;\n    }\n  });\n  var edgepaths = edgegroups.selectAll('.edgepath');\n\n  // Nodes\n  // note: nodes are added after edges so as to paint over excess edge lines\n  var nodeSelection = svg.selectAll('.node')\n    .data(nodeArray)\n    .enter();\n\n  var nodecircles = nodeSelection\n    .append('circle')\n      .attr('class', 'node')\n      .attr('r', nodeRadius)\n      .style('fill', function (d,i) { return colors(i); })\n      .each(function (d) { d.domNode = this; })\n      .on('dblclick', releasenode)\n      .call(drag);\n\n  var nodelabels = nodeSelection\n   .append('text')\n     .attr('class', 'nodelabel')\n     .attr('dy', '0.25em') /* dy doesn't work in CSS */\n     .text(function (d) { return d.label; });\n\n  // Arrowheads\n  var svgdefs = svg.append('defs');\n  svgdefs.selectAll('marker')\n      .data(['arrowhead', 'active-arrowhead', 'reversed-arrowhead', 'reversed-active-arrowhead'])\n    .enter().append('marker')\n      .attr({'id': function (d) { return d; },\n             'viewBox':'0 -5 10 10',\n             'refX': function (d) {\n               return (d.lastIndexOf('reversed-', 0) === 0) ? 0 : 10;\n             },\n             'orient':'auto',\n             'markerWidth':10,\n             'markerHeight':10\n            })\n    .append('path')\n      .attr('d', 'M 0 -5 L 10 0 L 0 5 Z')\n      .attr('transform', function (d) {\n        return (d.lastIndexOf('reversed-', 0) === 0) ? 'rotate(180 5 0)' : null;\n      });\n\n  var svgCSS =\n    '.edgepath {' +\n    '  marker-end: url(#arrowhead);' +\n    '}' +\n    '.edgepath.active-edge {' +\n    '  marker-end: url(#active-arrowhead);' +\n    '}' +\n    '.edgepath.reversed-arc {' +\n    '  marker-start: url(#reversed-arrowhead);' +\n    '  marker-end: none;' +\n    '}' +\n    '.edgepath.active-edge.reversed-arc {' +\n    '  marker-start: url(#reversed-active-arrowhead);' +\n    '  marker-end: none;' +\n    '}';\n  svg.append('style').each(function () {\n    if (this.styleSheet) {\n      this.styleSheet.cssText = svgCSS;\n    } else {\n      this.textContent = svgCSS;\n    }\n  });\n\n  // Force Layout Update\n  force.on('tick', function () {\n    // Keep coordinates in bounds. http://bl.ocks.org/mbostock/1129492\n    // NB. Bounding can cause node centers to coincide, especially at corners.\n    nodecircles.attr({cx: function (d) { return d.x = limitRange(nodeRadius, w - nodeRadius, d.x); },\n                      cy: function (d) { return d.y = limitRange(nodeRadius, h - nodeRadius, d.y); }\n    });\n\n    nodelabels.attr('x', function (d) { return d.x; })\n              .attr('y', function (d) { return d.y; });\n\n    edgepaths.attr('d', function (d) { return d.getPath(); });\n\n    edgegroups.each(function (d) { d.refreshLabels(); });\n\n    // Conserve CPU when layout is fully fixed\n    if (nodeArray.every(function (d) { return d.fixed; })) {\n      force.stop();\n    }\n  });\n  this.force = force;\n  /* eslint-enable no-invalid-this */\n}\n\n// Positioning\n\n// {[key: State]: Node} -> PositionTable\nvar getPositionTable = _.mapValues(_.pick(['x', 'y', 'px', 'py', 'fixed']));\n\n// Tag nodes w/ positions. Mutates the node map.\n// PositionTable -> {[key: State]: Node} -> void\nfunction setPositionTable(posTable, stateMap) {\n  _.forEach(function (node, state) {\n    var position = posTable[state];\n    if (position !== undefined) {\n      assign(node, position);\n    }\n  }, stateMap);\n}\n\nObject.defineProperty(StateViz.prototype, 'positionTable', {\n  get: function () { return getPositionTable(this.__stateMap); },\n  set: function (posTable) {\n    setPositionTable(posTable, this.__stateMap);\n    // ensure that a cooled layout will update\n    this.force.resume();\n  }\n});\n\n\nmodule.exports = StateViz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state-diagram/StateViz.js\n// module id = 49\n// module chunks = 0","'use strict';\nvar _ = require('lodash/fp');\n\n/*\n * supported unicode variants\n *\n * m: monospace\n * b: bold\n * i: italic\n * c: script\n * g: gothic / fraktur\n * d: double-struck\n * s: sans-serif\n * o: circled text\n * p: parenthesized latin letters\n * w: fullwidth\n */\n\nfunction toUnicodeVariant(str, variant, flags) {\n\n  var offsets = {\n    m: [0x1d670, 0x1d7f6],\n    b: [0x1d400, 0x1d7ce],\n    i: [0x1d434, 0x00030],\n    bi: [0x1d468, 0x00030],\n    c: [0x1d49c, 0x00030],\n    bc: [0x1d4d0, 0x00030],\n    g: [0x1d504, 0x00030],\n    d: [0x1d538, 0x1d7d8],\n    bg: [0x1d56c, 0x00030],\n    s: [0x1d5a0, 0x1d7e2],\n    bs: [0x1d5d4, 0x1d7ec],\n    is: [0x1d608, 0x00030],\n    bis: [0x1d63c, 0x00030],\n    o: [0x24B6, 0x2460],\n    p: [0x249C, 0x2474],\n    w: [0xff21, 0xff10],\n    u: [0x2090, 0xff10]\n  };\n\n  var variantOffsets = {\n    'monospace': 'm',\n    'bold' : 'b',\n    'italic' : 'i',\n    'bold italic' : 'bi',\n    'script': 'c',\n    'bold script': 'bc',\n    'gothic': 'g',\n    'gothic bold': 'bg',\n    'doublestruck': 'd',\n    'sans': 's',\n    'bold sans' : 'bs',\n    'italic sans': 'is',\n    'bold italic sans': 'bis',\n    'parenthesis': 'p',\n    'circled': 'o',\n    'fullwidth': 'w'\n  };\n\n  // special characters (absolute values)\n  var special = {\n    m: {\n      ' ': 0x2000,\n      '-': 0x2013\n    },\n    i: {\n      'h': 0x210e\n    },\n    g: {\n      'C': 0x212d,\n      'H': 0x210c,\n      'I': 0x2111,\n      'R': 0x211c,\n      'Z': 0x2128\n    },\n    o: {\n      '0': 0x24EA,\n      '1': 0x2460,\n      '2': 0x2461,\n      '3': 0x2462,\n      '4': 0x2463,\n      '5': 0x2464,\n      '6': 0x2465,\n      '7': 0x2466,\n      '8': 0x2467,\n      '9': 0x2468,\n    },\n    p: {},\n    w: {}\n  };\n  //support for parenthesized latin letters small cases\n  for (var i = 97; i <= 122; i++) {\n    special.p[String.fromCharCode(i)] = 0x249C + (i-97);\n  }\n  //support for full width latin letters small cases\n  for (i = 97; i <= 122; i++) {\n    special.w[String.fromCharCode(i)] = 0xff41 + (i-97);\n  }\n\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n  var numbers = '0123456789';\n\n  var getType = function (variantt) {\n    if (variantOffsets[variantt]) return variantOffsets[variantt];\n    if (offsets[variantt]) return variantt;\n    return 'm'; //monospace as default\n  };\n  var getFlag = function (flag, flagz) {\n    if (!flagz) return false;\n    return flagz.split(',').indexOf(flag)>-1;\n  };\n\n  var type = getType(variant);\n  var underline = getFlag('underline', flags);\n  var strike = getFlag('strike', flags);\n  var result = '';\n\n  for (i = 0; i < str.length; i++) {\n    var k = str.charAt(i);\n    var index;\n    var c = k;\n    if (special[type] && special[type][c]) c = String.fromCodePoint(special[type][c]);\n    if (type && (index = chars.indexOf(c)) > -1) {\n      result += String.fromCodePoint(index + offsets[type][0]);\n    } else if (type && (index = numbers.indexOf(c)) > -1) {\n      result += String.fromCodePoint(index + offsets[type][1]);\n    } else {\n      result += c;\n    }\n    if (underline) result += '\\u0332'; // add combining underline\n    if (strike) result += '\\u0336'; // add combining strike\n  }\n  return result;\n}\n\n// Bidirectional infinite tape\nfunction Tape(blank, input) {\n  Object.defineProperty(this, 'blank', {\n    value: blank,\n    writable: false,\n    enumerable: true\n  });\n  // zipper data structure\n  // INVARIANTS: tape.before can be empty, tape.after must be nonempty.\n  // before: cells before the head (in order; left to right).\n  // after:  cells after and including the head (in reverse; right to left).\n  this.tape = {\n    before: [],\n    after: (input == null || input.length == 0) ? [blank] : input.slice().reverse(),\n    toString: function () {\n      return this.before.join('') + toUnicodeVariant(_.last(this.after), 'circled') + this.after.slice(0, this.after.length-1).reverse().join('');\n    }\n  };\n}\n\n// Read the value at the tape head.\nTape.prototype.read = function () {\n  return _.last(this.tape.after);\n};\nTape.prototype.write = function (symbol) {\n  this.tape.after[this.tape.after.length - 1] = symbol;\n};\n\nTape.prototype.headRight = function () {\n  var before = this.tape.before,\n      after = this.tape.after;\n  before.push(after.pop());\n  if (_.isEmpty(after)) {\n    after.push(this.blank);\n  }\n};\nTape.prototype.headLeft = function () {\n  var before = this.tape.before,\n      after = this.tape.after;\n  if (_.isEmpty(before)) {\n    before.push(this.blank);\n  }\n  after.push(before.pop());\n};\n\nTape.prototype.toString = function () {\n  return this.tape.toString();\n};\n\n// for tape visualization. not part of TM definition.\n// Read the value at an offset from the tape head.\n// 0 is the tape head. + is to the right, - to the left.\nTape.prototype.readOffset = function (i) {\n  var tape = this.tape;\n  if (i >= 0) {\n    // right side: offset [0..length-1] ↦ array index [length-1..0]\n    return (i <= tape.after.length - 1) ? tape.after[tape.after.length - 1 - i] : this.blank;\n  } else {\n    // left side: offset [-1..-length] ↦ array index [length-1..0]\n    return (i >= -tape.before.length) ? tape.before[tape.before.length + i] : this.blank;\n  }\n};\n\n// for tape visualization.\n// Read the values from an offset range (inclusive of start and end).\nTape.prototype.readRange = function (start, end) {\n  return _.range(start, end+1).map(function (i) {\n    return this.readOffset(i);\n  }, this);\n};\n\nmodule.exports = Tape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/Tape.js\n// module id = 50\n// module chunks = 0","'use strict';\nvar Tape = require('./Tape.js'),\n    d3   = require('d3');\nrequire('./tape.css');\n\nvar cellWidth = 50;\nvar cellHeight = 50;\n\nfunction initTapeCells(selection) {\n  selection.attr('class', 'tape-cell');\n  selection.append('rect')\n      // the box outline is purely visual, so remove its data binding\n      .datum(null)\n      .attr({'width': cellWidth,\n             'height': cellHeight});\n  selection.append('text')\n      .text(function (d) { return d; })\n      .attr({'x': cellWidth/2, 'y': cellHeight/2 + 8});\n  return selection;\n}\n\nfunction positionCells(selection, offset) {\n  offset = (offset == null) ? 0 : offset;\n  selection.attr('transform', function (d, i) {\n    return 'translate(' + (-cellWidth+10 + cellWidth*(i+offset)) + ')';\n  });\n  return selection;\n}\n\nfunction repositionWrapper(wrapper) {\n  wrapper.attr('transform', 'translate(0 10)')\n    .transition()\n      .duration(0)\n    .select('.exiting')\n      .remove();\n}\n\n// Tape visualization centered around the tape head.\nfunction TapeViz(svg, lookaround, blank, input) {\n  Tape.call(this, blank, input);\n\n  Object.defineProperty(this, 'lookaround', {\n    value: lookaround,\n    writable: false,\n    enumerable: true\n  });\n  Object.defineProperty(this, 'domNode', {\n    value: svg,\n    writable: false,\n    enumerable: true\n  });\n\n  // width is before + head + after, trimming 2 off to show cut-off tape ends\n  var width  = cellWidth * (lookaround+1+lookaround-2) + 2*10;\n  var height = cellHeight + 2*10;\n  svg.attr({\n    'width': '95%',\n    'viewBox': [0, 0, width, height].join(' ')\n  });\n\n  this.wrapper = svg.append('g')\n      .attr('class', 'wrapper')\n      .call(repositionWrapper);\n\n  svg.append('rect')\n      .attr({'id': 'tape-head',\n             'width': (1+1/5) * cellWidth,\n             'height': (1+1/5) * cellHeight,\n             'x': -cellWidth+10/2 + cellWidth*lookaround,\n             'y': 10/2\n           });\n\n  this.wrapper.selectAll('.tape-cell')\n      .data(this.readRange(-lookaround, lookaround))\n    .enter()\n    .append('g')\n      .call(initTapeCells)\n      .call(positionCells)\n  ;\n}\n\nTapeViz.prototype = Object.create(Tape.prototype);\nTapeViz.prototype.constructor = TapeViz;\n\n// IDEA: chain headLeft/Right to wait for write()?\nTapeViz.prototype.write = function (symbol) {\n  // don't animate if symbol stays the same\n  if (Tape.prototype.read.call(this) === symbol) {\n    return;\n  }\n  Tape.prototype.write.call(this, symbol);\n\n  // remove leftover .exiting in case animation was interrupted\n  this.wrapper.selectAll('.exiting').remove();\n\n  d3.select(this.wrapper[0][0].childNodes[this.lookaround])\n      .datum(symbol)\n    .select('text')\n      .attr('fill-opacity', '1')\n      .attr('stroke-opacity', '1')\n    .transition()\n      .attr('fill-opacity', '0.4')\n      .attr('stroke-opacity', '0.1')\n    .transition()\n      .text(function (d) { return d; })\n      .attr('fill-opacity', '1')\n      .attr('stroke-opacity', '1')\n    .transition()\n      .duration(0)\n      .attr('fill-opacity', null)\n      .attr('stroke-opacity', null)\n    ;\n};\n\nfunction moveHead(wrapper, enter, exit, wOffset, cOffset) {\n  // add to one end\n  enter.call(initTapeCells);\n  // remove from the other end\n  exit.classed('exiting', true);\n  // translate cells forward, and the wrapper backwards\n  wrapper.selectAll('.tape-cell')\n      .call(positionCells, cOffset);\n  wrapper\n      .attr('transform', 'translate(' + (wOffset*cellWidth).toString() + ' 10)')\n    // animate wrapper returning to neutral position\n    .transition()\n      .call(repositionWrapper);\n}\n\nTapeViz.prototype.headRight = function () {\n  Tape.prototype.headRight.call(this);\n  // remove leftover .exiting in case animation was interrupted.\n  // Important: call-by-value evaluates the selection argument(s) of 'moveHead' before\n  // before entering the function, so exiting nodes have to be removed beforehand.\n  this.wrapper.selectAll('.exiting').remove();\n  moveHead(this.wrapper,\n    // add to right end\n    this.wrapper.append('g')\n        .datum(this.readOffset(this.lookaround)),\n    // remove from left end\n    this.wrapper.select('.tape-cell'),\n    1, -1);\n};\n\nTapeViz.prototype.headLeft = function () {\n  Tape.prototype.headLeft.call(this);\n  this.wrapper.selectAll('.exiting').remove();\n  moveHead(this.wrapper,\n    this.wrapper.insert('g', ':first-child')\n        .datum(this.readOffset(-this.lookaround)),\n    this.wrapper.select('.wrapper > .tape-cell:last-of-type'),\n    -1, 0);\n};\n\nmodule.exports = TapeViz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tape/TapeViz.js\n// module id = 51\n// module chunks = 0"],"sourceRoot":""}